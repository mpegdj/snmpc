네, 이 화면 기준으로는 **MIB 로드/파싱 자체는 정상**으로 보입니다.

- **증거**: `Private(1.3.6.1.4.1) → nel(…3930) → mve5000(…3930.36)` 아래로 하위 트리가 풍부하게 생성돼 있어요.
- **다만 한 가지 이상 징후**: `nel` 아래에 **`IMPORTS (1.3.6.1.4.1.3930.37)`**가 노드로 잡혀 있는데, 이 OID 위치는 보통 `mvd5000(…3930.37)` 같은 모듈 루트가 와야 해서 **이름 매칭이 한 번 꼬인 흔적**은 있습니다(그래도 트리는 만들어짐).

다음으로 뭘 할까요?  
- **(A)** “지금 이 커밋(`c8d1784`)이 정상”이라고 결론만 내릴지  
- **(B)** 문제 커밋(예: `75aa832` 또는 최신)에서 다시 실행해서 **차이를 캡처**할지  
원하는 걸 말해줘요.

알겠어. **`c8d1784`에서 “MIB 파일을 어떻게 읽고(Load) 어떤 규칙으로 파싱해서(OID/이름 매핑 생성) 트리로 만드는지”를 코드 기준으로 정확히 분석해서**, 나중에 현재 커밋으로 돌아가도 참고할 수 있게 이 채팅에 정리해둘게.  
다음으로 `SnmpNms.Infrastructure/MibService.cs`(핵심)와 연결된 트리 빌드/필터 부분까지 읽고, **파싱 단계(입력→정규화→매칭→등록→트리화)** 순서로 설명하겠다.

[3 tools called]

### 결론(이 채팅에 남겨둘 핵심)
`c8d1784`에서 MIB “파싱”은 **`SnmpNms.Infrastructure/MibService.cs`의 `LoadMibModules()` → `ParseMibFile()`**에서 이뤄지고, 결과는 **`_oidToName`(OID→이름), `_nameToOid`(이름→OID)** 두 딕셔너리에 쌓입니다. 그 다음 **`GetMibTree()` → `BuildTreeFromOids()`**가 딕셔너리를 바탕으로 **UI에 보여줄 트리 구조를 생성**합니다.

---

### 1) 파싱 결과를 담는 자료구조(가장 중요)
`MibService`는 파싱 결과를 아래 2개 맵에 저장합니다.

```10:15:SnmpNms.Infrastructure/MibService.cs
// OID -> Name (e.g., "1.3.6.1.2.1.1.3" -> "sysUpTime")
private readonly Dictionary<string, string> _oidToName = new();

// Name -> OID (e.g., "sysUpTime" -> "1.3.6.1.2.1.1.3")
private readonly Dictionary<string, string> _nameToOid = new();
```

- **핵심 포인트**: 이 커밋의 `_nameToOid`는 **기본 Dictionary(대소문자 구분)** 입니다. 즉, 부모 심볼 이름이 대소문자라도 어긋나면(예: `NEL` vs `nel`) `TryGetValue`가 실패해서 OID 등록이 안 될 수 있습니다.

---

### 2) “파싱이 되기 위한 최소 전제”: 루트 OID 선등록
생성자에서 표준 루트/기본 심볼 일부를 **하드코딩으로 먼저 등록**합니다. 이게 있어야 vendor MIB의 `enterprises` 같은 부모 심볼을 해석할 수 있습니다.

```16:31:SnmpNms.Infrastructure/MibService.cs
public MibService()
{
    // 기본 표준 MIB 중 가장 흔한 것들만 하드코딩으로 미리 등록 (필수)
    Register("1.3.6.1.2.1.1.1", "sysDescr");
    // ...
    // 표준 루트 OID 정의
    Register("1.3.6.1", "iso.org.dod.internet");
    Register("1.3.6.1.4.1", "enterprises");
    Register("1.3.6.1.2.1", "mgmt");
}
```

---

### 3) 어떤 파일을 읽나(입력 범위)
지정 디렉터리 아래에서 `*.mib`와 `*.txt`를 **재귀적으로 전부 읽어서** 각각 파싱합니다.

```41:53:SnmpNms.Infrastructure/MibService.cs
public void LoadMibModules(string directoryPath)
{
    if (!Directory.Exists(directoryPath)) return;

    var files = Directory.GetFiles(directoryPath, "*.mib", SearchOption.AllDirectories)
        .Concat(Directory.GetFiles(directoryPath, "*.txt", SearchOption.AllDirectories))
        .ToList();

    foreach (var file in files)
    {
        ParseMibFile(file);
    }
}
```

- **중요**: `*.txt`도 포함이라서 “Trap 텍스트” 같은 파일도 들어옵니다(대부분은 매칭이 안 돼서 OID 추가가 0).

---

### 4) 파싱 로직의 실제 동작(3단계 + 최대 10회 반복)
`ParseMibFile()`이 “파싱의 전부”입니다. 구조는 아래처럼 **반복(최대 10회)** 하면서 의존성을 풀어갑니다.

- **반복 이유**: 예를 들어 `mvd5000General ::= { mvd5000 1 }` 같은 하위 정의는 `mvd5000`가 먼저 등록돼 있어야 계산 가능. 한 번 훑고 끝내지 않고 **부모가 채워질 때까지 여러 번 시도**합니다.

```55:161:SnmpNms.Infrastructure/MibService.cs
private void ParseMibFile(string filePath)
{
    var content = File.ReadAllText(filePath);

    // 여러 번 반복 파싱하여 의존성 해결 (최대 10회)
    for (int iteration = 0; iteration < 10; iteration++)
    {
        var beforeCount = _oidToName.Count;

        // 1단계: OBJECT IDENTIFIER 정의 파싱
        var oidDefRegex = new Regex(
            @"^([a-zA-Z0-9_-]+)\s+OBJECT\s+IDENTIFIER\s*::=\s*\{\s*([a-zA-Z0-9_-]+)\s+(\d+)\s*\}",
            RegexOptions.Multiline | RegexOptions.IgnoreCase);

        // 2단계: MODULE-IDENTITY 정의 파싱
        var moduleIdentityRegex = new Regex(
            @"^([a-zA-Z0-9_-]+)\s+MODULE-IDENTITY[\s\S]*?::=\s*\{\s*([a-zA-Z0-9_-]+)\s+(\d+)\s*\}",
            RegexOptions.Multiline | RegexOptions.IgnoreCase);

        // 3단계: OBJECT-TYPE 정의 파싱
        var objectTypeRegex = new Regex(
            @"^([a-zA-Z0-9_-]+)\s+OBJECT-TYPE[\s\S]*?::=\s*\{\s*([a-zA-Z0-9_-]+)\s+(\d+)\s*\}",
            RegexOptions.Multiline);

        // 각 Match마다: (name, parentName, lastId) 뽑고 parentName의 OID를 찾아 currentOid = parentOid.lastId로 Register
        // (부모를 모르면 등록 못 함)

        // 더 이상 새로운 항목이 추가되지 않으면 종료
        if (_oidToName.Count == beforeCount)
            break;
    }
}
```

#### 4-1) “등록(Register)” 규칙
이름/oid가 이미 있으면 중복 등록을 막고, **부모 OID를 찾을 수 있을 때만** 자식 OID를 만들어 등록합니다. 단, 부모가 `enterprises`인 경우는 예외로 직접 `1.3.6.1.4.1.<id>`로 만듭니다.

```82:99:SnmpNms.Infrastructure/MibService.cs
// 이미 등록되어 있으면 스킵
if (_nameToOid.ContainsKey(name)) continue;

// 부모 OID를 알고 있다면 현재 OID 완성 가능
if (_nameToOid.TryGetValue(parentName, out var parentOid))
{
    var currentOid = $"{parentOid}.{lastId}";
    Register(currentOid, name);
}
// enterprises는 특별 처리 (1.3.6.1.4.1)
else if (parentName.Equals("enterprises", StringComparison.OrdinalIgnoreCase))
{
    var currentOid = $"1.3.6.1.4.1.{lastId}";
    Register(currentOid, name);
}
```

---

### 5) 왜 이 커밋에서 `nel → mve5000/mvd5000`가 “잘 파싱되는가”(증상과 직접 연결)
Vendor MIB가 흔히 이런 형태라면:

- `nel OBJECT IDENTIFIER ::= { enterprises 3930 }`
- `mve5000 MODULE-IDENTITY ... ::= { nel 36 }`
- `mvd5000 MODULE-IDENTITY ... ::= { nel 37 }`
- 그리고 그 아래 수백/수천개의 `OBJECT IDENTIFIER` / `OBJECT-TYPE ... ::= { mve5000Something N }`

이 커밋에서는:

1) 생성자에서 `enterprises = 1.3.6.1.4.1`가 이미 등록됨  
2) 1단계에서 `nel`을 `enterprises 3930`로 해석 가능 → `nel = 1.3.6.1.4.1.3930` 등록  
3) 2단계에서 `mve5000/mvd5000`를 `nel 36/37`로 해석 가능 → 모듈 루트 등록  
4) 3단계에서 그 아래 OBJECT-TYPE들이 부모를 찾으면서 폭발적으로 등록됨  
5) 반복(최대 10회)이 있어서 “파일 안에서 선언 순서가 뒤죽박죽”이어도 부모가 채워지면 다음 iteration에서 자식이 붙습니다.

---

### 6) 트리는 파싱이 아니라 “OID 세그먼트 분해”로 만든다(중요한 오해 방지)
UI에 보이는 트리는 “MIB 문법 트리”가 아니라, `_oidToName`의 OID를 `.`로 쪼개서 만든 **세그먼트 트리**입니다.

```266:321:SnmpNms.Infrastructure/MibService.cs
foreach (var kvp in _oidToName)
{
    var oid = kvp.Key;
    var name = kvp.Value;

    // mgmt 또는 Private 하위만 트리로
    if (oid.StartsWith("1.3.6.1.2.1")) { rootNode = mgmtNode; relativeOid = ... }
    else if (oid.StartsWith("1.3.6.1.4.1")) { rootNode = privateNode; relativeOid = ... }
    if (rootNode is null || string.IsNullOrEmpty(relativeOid)) continue;

    var segments = relativeOid.Split('.');
    for (int i = 0; i < segments.Length; i++)
    {
        // 마지막만 "실제 이름(name)"을 쓰고, 중간은 "숫자 세그먼트"를 이름으로 씀
        var nodeName = (i == segments.Length - 1) ? name : segments[i];
        // ...
        currentParent.Children.Add(segmentNode);
        currentParent = segmentNode;
    }
}
```

- **여기서 중요한 결과**:
  - 중간 폴더 노드의 이름은 대부분 `36`, `37` 같은 숫자가 됩니다.
  - 어떤 OID가 “그 세그먼트 자체로” `_oidToName`에 등록되어 있으면(예: `...3930.37 -> mvd5000`) 그 OID가 leaf로 잡히며 **이름이 표시**됩니다.
  - 그래서 스크린샷처럼 특정 위치에 이상한 이름이 보이면, “트리 로직” 문제가 아니라 **그 OID에 잘못된 이름이 등록된(=파싱 결과가 그렇게 나온)** 흔적일 가능성이 큽니다.

---

### 7) 현재 커밋으로 돌아가서도 이 분석으로 확인할 체크리스트
현재 커밋에서 “nel 자식이 사라짐”이 재발하면, 아래가 깨진 겁니다(이 커밋 기준으로):

- **(필수)** `enterprises`가 사전에 등록돼 있는가 (`1.3.6.1.4.1`)  
- **(필수)** 1단계 `OBJECT IDENTIFIER` 정규식이 vendor 파일의 들여쓰기/형식을 매칭하는가  
- **(필수)** `_nameToOid`가 부모 이름을 찾을 수 있는 형태(대소문자/정규화)인가  
- **(필수)** 2단계 `MODULE-IDENTITY`가 `mve5000/mvd5000` 루트를 제대로 등록하는가  
- **(결과)** `_oidToName` 총 개수가 “수천 단위”로 올라가는가(트리 노드 수가 늘어남)

원하면 다음 지시만 해줘: “현재 커밋에서 `_oidToName`이 왜 안 차는지(어느 단계에서 0이 되는지) ‘읽기만’으로 확인해봐.” 그러면 **코드 수정 없이**, 현재 커밋의 `MibService`가 위 구조에서 어디가 달라졌는지 정확히 비교해서 이 채팅에 추가로 남겨둘게.


맞아요. 그 “`mvd5000`가 왜 `IMPORTS`로 표시되나”의 원인은 **정규식에서 `\s+`가 “줄바꿈(개행)”까지 먹어버리는 것** 때문입니다.

### 왜 `IMPORTS`가 `mvd5000` 자리를 먹나
`c8d1784`의 `MODULE-IDENTITY` 파서 정규식은 앞부분이 이렇게 생겼어요.

```105:105:SnmpNms.Infrastructure/MibService.cs
var moduleIdentityRegex = new Regex(@"^([a-zA-Z0-9_-]+)\s+MODULE-IDENTITY[\s\S]*?::=\s*\{\s*([a-zA-Z0-9_-]+)\s+(\d+)\s*\}", RegexOptions.Multiline | RegexOptions.IgnoreCase);
```

- `^([a-zA-Z0-9_-]+)`가 **어떤 라인의 첫 토큰**을 잡습니다.
- 그 다음의 `\s+MODULE-IDENTITY`에서 `\s+`는 **스페이스/탭뿐 아니라 개행도 포함**합니다.
- 그래서 파일에 `IMPORTS`가 라인 시작에 있고, 그 뒤 “어딘가”에 `MODULE-IDENTITY`가 나오면, 정규식은 아래처럼 “라인을 건너뛰며” 매칭될 수 있어요:

- `^IMPORTS` (그룹1 = `IMPORTS`)
- `\s+`가 여러 줄을 통째로 삼킴
- 나중에 등장한 `MODULE-IDENTITY`를 만나서 패턴이 계속 진행
- 결국 `::= { nel 37 }` 같은 곳까지 이어져서 **OID `…3930.37`을 `IMPORTS`라는 이름으로 Register**
- 트리는 leaf에서 등록된 name을 그대로 보여주니까, UI에서 `IMPORTS (1.3.6.1.4.1.3930.37)`로 보이게 됩니다.

### 결론
- **`mvd5000`가 `IMPORTS`로 보이는 건 트리 문제가 아니라 “파싱 결과(_oidToName)에 그 OID가 IMPORTS로 잘못 들어갔기 때문”**입니다.
- 근본 원인은 **`^토큰 \s+ KEYWORD`에서 `\s+`가 개행을 포함**한다는 점입니다.

좋아. **지금 `c8d1784`에서, 아까 우리가 되돌리기 전 “현재 HEAD 상태”로 다시 이동**할게. 안전하게 남겨둔 백업 브랜치(`backup/before-reset-20251228-114326`)로 체크아웃만 하고, stash는 건드리지 않겠다(원하면 그때 적용).

[1 tool called]

### 현재 커밋으로 복귀 완료

- **현재 브랜치**: `backup/before-reset-20251228-114326`
- **현재 HEAD**: `64aaca4` (`MODULE-IDENTITY` 원인파악악)
- **작업트리 상태**: clean (변경 없음)

원하면 다음 지시해줘:
- **stash까지 포함해서 당시 수정분까지 복원**: `stash@{0}`를 적용할까, 아니면 커밋 상태만 유지할까?

좋아. 목표는 **네가 저장해둔 분석(문서)**을 다시 읽고, 지금 `main`(현재 커밋)에서 **왜 MIB 트리가 깨지는지(특히 `nel` 하위)**를 **코드 변경 없이** 원인까지 특정하는 거야.  
다음으로 문서(`Doc/17`, `Doc/16`, 비교문서)와 현재 `MibService.cs`, UI 쪽에서 MIB 트리/필터를 만지는 부분을 읽어서 차이를 뽑아낼게.

[6 tools called]

좋아, 저장된 분석(=문서 16/17) 기준으로 보면 “`nel` 하위가 비는 문제”는 **파싱 단계에서 `_oidToName/_nameToOid`가 거의 안 채워지는 케이스**가 핵심이었고, 반대로 지금 `c8d1784` 쪽은 파싱은 되지만 **`IMPORTS`가 모듈 이름 자리를 먹는 오인식**이 남아있었어.  
이제 남은 건 “현재 `main`에서 실제 코드/문서 비교”로, **정확히 어떤 변경이 `totalOids=11` 같은 상태를 만드는지**(정규식/부모심볼해결/순서/필터) 지점을 찍는 거야.

[16 tools called]

### 저장해둔 분석(16/17) 다시 읽은 뒤, **현재 커밋(main) 문제점** 결론

#### 1) “UI 필터 때문에 `nel` 자식이 숨는다”는 가능성은 낮음
`SidebarMibView.xaml`에는 **MIB 트리를 숨기는 필터 로직이 없고**, OID 문자열이 비어있을 때만 `(oid)` 표시를 접는 정도입니다.

```11:36:SnmpNms.UI/Views/SidebarMibView.xaml
<TextBlock Text=" (" 
           Foreground="{StaticResource VSCodeForeground}"
           Visibility="{Binding Oid, Converter={StaticResource StringToVisibilityConverter}}"/>
<TextBlock Text="{Binding Oid}"
           Foreground="#666"
           Visibility="{Binding Oid, Converter={StaticResource StringToVisibilityConverter}}"/>
<TextBlock Text=")" 
           Foreground="{StaticResource VSCodeForeground}"
           Visibility="{Binding Oid, Converter={StaticResource StringToVisibilityConverter}}"/>
```

```7:16:SnmpNms.UI/Converters/StringToVisibilityConverter.cs
if (value is string str && !string.IsNullOrEmpty(str))
{
    return Visibility.Visible;
}
return Visibility.Collapsed;
```

즉, `nel` 하위가 비는 문제는 **파싱/매핑(_oidToName/_nameToOid) 쪽이 원인일 확률이 훨씬 큼**.

---

### 2) 현재 커밋에서 확인된 “눈에 보이는 이상 현상”: `mvd5000`이 `IMPORTS`로 표시되는 이유(확정)
핵심은 두 가지가 동시에 겹칩니다.

#### (A) `MODULE-IDENTITY` 정규식이 **IMPORTS 블록을 오인식**
현재 `MibService.ParseMibFile()`의 2단계 정규식:

```102:131:SnmpNms.Infrastructure/MibService.cs
var moduleIdentityRegex = new Regex(@"^([a-zA-Z0-9_-]+)\s+MODULE-IDENTITY[\s\S]*?::=\s*\{\s*([a-zA-Z0-9_-]+)\s+(\d+)\s*\}", RegexOptions.Multiline | RegexOptions.IgnoreCase);
```

그런데 실제 MIB 파일은 IMPORTS 섹션에서 “가져오는 심볼 목록”에 **`MODULE-IDENTITY`라는 단어가 그대로 등장**합니다:

```16:45:Mib/mvd5000/MVD5000_Ver05.20.mib.txt
IMPORTS
        MODULE-IDENTITY, OBJECT-TYPE, Counter32, Gauge32, Counter64,
...
mvd5000 MODULE-IDENTITY
...
        ::= { nel 37 }
```

`^IMPORTS` 다음 줄이 공백으로 들여쓰기 된 `MODULE-IDENTITY, ...`라서, 정규식의 `\s+MODULE-IDENTITY`가 **“키워드”가 아니라 “IMPORTS에서 import하는 심볼 이름”**에 매칭돼버립니다.  
그래서 group1(name)이 **`IMPORTS`로 잡힌 채**, 뒤쪽의 `::= { nel 37 }`까지 이어져서 **OID `...3930.37`을 `IMPORTS` 이름으로 먼저 등록**할 수 있습니다.

#### (B) `Register()`가 **OID 중복 시에도 name→oid는 추가**해서 “표시는 IMPORTS, 파싱은 진행”이 가능해짐
현재 `Register()`는 `_oidToName`과 `_nameToOid`를 **각각 따로** 넣습니다.

```33:39:SnmpNms.Infrastructure/MibService.cs
if (!_oidToName.ContainsKey(oid)) _oidToName[oid] = name;
if (!_nameToOid.ContainsKey(name)) _nameToOid[name] = oid;
```

그래서 흐름이 이렇게 됩니다:

- 오인식 매칭으로 `_oidToName["...3930.37"] = "IMPORTS"`가 먼저 들어감
- 나중에 진짜 `mvd5000 MODULE-IDENTITY ... ::= { nel 37 }`를 만나도
  - `_oidToName`는 **이미 키가 있어서 덮어쓰기 안 됨** → 트리 표시 이름은 계속 `IMPORTS`
  - 하지만 `_nameToOid["mvd5000"] = "...3930.37"`는 **추가됨** → 이후 `mvd5000General ::= { mvd5000 1 }` 같은 하위 파싱은 계속 진행 가능

이 조합이 바로 스크린샷에서 보인 **`IMPORTS (…3930.37)` 아래에 mvd5000 하위가 달리는 현상**을 설명합니다.

---

### 3) “`nel` 자식이 사라진다” 쪽(문서 16 로그: totalOids=11)과의 연결
문서 16의 증상(`totalOids=11`, `mve5000/mvd5000=N/A`)은 결국 **`mve5000/mvd5000`가 `_nameToOid`에 못 들어가서**, 그 아래 수천 개 정의가 “부모를 못 찾아” 등록이 거의 안 되는 상태를 의미해요.

현재 커밋(main)에서 위 (B)처럼 `_nameToOid`가 살아있으면 “표시 이름은 꼬여도 파싱은 진행”이 가능한데,  
반대로 어느 지점에서든 **`_nameToOid` 등록이 막히면** 문서 16처럼 `nel` 아래가 텅 비는 증상으로 직결됩니다.

---

### 참고(중요): 네가 IDE에서 열어둔 0.1 비교 문서들
지금 `main`의 `Doc/` 폴더에는 `0.1.commit...`/`comparison...` 파일들이 **아예 존재하지 않고**(디렉터리 리스트 기준), `16/17`만 남아있어. 그래서 “저장해둔 분석”의 본문은 `Doc/16`, `Doc/17`을 기준으로만 추적 가능해.

좋아, “한꺼번에 체크”는 결국 **(1) MIB Tree가 왜 깨지는지(우선)**를 먼저 원인 확정하고, 그 다음에 나머지(Trap/로그/UI 등)를 훑는 순서가 הכי 효율적이야.  
지금 커밋에서 파싱 정규식이 실제로 `IMPORTS`를 `MODULE-IDENTITY`로 오인식하는지(=현상 재현)부터 **코드 수정 없이** 터미널에서 바로 증거를 뽑아볼게.

[1 tool called]

### MIB Tree 우선 결론(증거로 확정)

방금 터미널에서 **현재 커밋의 `MODULE-IDENTITY` 정규식이 실제로 `mvd5000/mve5000`가 아니라 `IMPORTS`를 잡는 게 확정**됐어.

- `MVD5000_Ver05.20.mib.txt`: `matchCount=1`, **`name=IMPORTS parent=nel id=37`**
- `MVE5000_Ver05.20.mib.txt`: `matchCount=1`, **`name=IMPORTS parent=nel id=36`**

즉 지금 커밋의 파서는 `mvd5000 MODULE-IDENTITY` 라인을 **아예 못 잡고**, IMPORTS 블록을 오인식해서:
- `1.3.6.1.4.1.3930.36`/`.37` 같은 “모듈 루트 OID”에 **이름을 `IMPORTS`로 등록**하게 됨
- 그 결과 MIB Tree에서 **`IMPORTS (…3930.37)`처럼 표시**되거나, 더 나쁘면 하위 등록이 연쇄 실패해서 `nel` 하위가 비는 문제가 생길 수 있음

### 다음 지시만 줘
- **“그럼 고쳐”** 라고 하면, *딱 MibService의 정규식만* 최소 수정해서 **`mve5000/mvd5000`가 잡히고 `IMPORTS`가 안 잡히게** 만들겠다.  
- **“일단 현상만 더 확인”**이면, 지금 상태에서 `_oidToName/_nameToOid`에 뭐가 들어가는지(36/37이 IMPORTS로 박혔는지) 추가로 **읽기/출력만** 해서 증거를 더 붙이겠다.

좋아. 지금 커밋에서 **`MODULE-IDENTITY` 정규식이 `IMPORTS`를 모듈 이름으로 오인식**하는 게 원인이 확정됐으니, 그 부분만 **최소 수정**해서 `mve5000/mvd5000`가 제대로 잡히게 고칠게. 수정 후에는 방금 했던 정규식 매칭 테스트를 다시 돌려서 “이제 name이 IMPORTS가 아니라 mve5000/mvd5000으로 잡힌다”까지 증거로 확인하겠다.

[6 tools called]

### 수정 완료: MIB Tree 깨짐(IMPORTS 오인식) 원인 고침

- **수정 내용**: `SnmpNms.Infrastructure/MibService.cs`의 `MODULE-IDENTITY` 정규식에서 `\s+` 때문에 개행까지 먹으며 `^IMPORTS`를 name으로 잡던 문제를 막기 위해,
  - name과 `MODULE-IDENTITY` 사이를 **공백/탭만 허용(`[ \t]+`)**
  - 라인 시작 공백 허용(`^\s*`)
  - `MODULE-IDENTITY\b`로 단어 경계 지정  
  으로 **최소 변경**했어.

- **증거(재검증 결과)**: 수정 후 같은 테스트를 돌리니 이제 **IMPORTS가 아니라 모듈명이 정확히 잡힘**
  - `MVD5000_Ver05.20.mib.txt`: `name=mvd5000 parent=nel id=37`
  - `MVE5000_Ver05.20.mib.txt`: `name=mve5000 parent=nel id=36`

이제 앱 실행하면 `nel` 아래에서 **`IMPORTS (…3930.37)` 같은 잘못된 표시가 사라지고**, `mve5000/mvd5000`가 루트로 잡혀서 트리 구조가 정상으로 돌아오는 게 기대 동작이야.

결과 성공 251228:12:24

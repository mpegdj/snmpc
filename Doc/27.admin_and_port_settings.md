# 통합 가이드 - v1.5 패치 (관리자 권한, 방화벽, 크래시 수정)

이 문서는 v1.5 업데이트에서 적용된 관리자 권한 획득, 방화벽 자동 설정 및 주요 UI 크래시 수정 사항을 통합하여 설명합니다.

## 1. 개요 및 흐름도

애플리케이션은 시작 시 시스템 환경을 침해하지 않는 범위 내에서 다음 단계를 거칩니다.

1. **상태 체크**: 현재 윈도우 방화벽에 SNMP Trap (UDP 162) 인바운드 규칙이 있는지 확인합니다.
2. **조건부 권한 요청**: 
    - 규칙이 **없고** 일반 권한으로 실행 중이라면, 사용자에게 팝업을 띄워 관리자 권한 승인을 요청합니다.
    - 규칙이 이미 있거나 이미 관리자라면 즉시 실행합니다.
3. **방화벽 등록**: 관리자 권한 획득 시에만 `netsh` 명령어로 포트 허용 규칙을 자동 추가합니다.
4. **포트 바인딩**: `TrapListener` 서비스가 시작될 때 실제 UDP 162 포트를 점유(Binding)합니다.

## 2. 권한 획득 전략

`dotnet run` 환경과의 호환성 및 최소 권한 원칙을 위해 다음과 같이 동작합니다.

### 관리자 권한 필요 여부 판단
```csharp
if (!result.Firewall162Registered && !result.IsAdmin)
{
    // 여기서만 사용자에게 팝업을 띄우고 RestartAsAdministrator() 호출 가능성 발생
}
```

## 3. 포트별 상태 정의

- **UDP 161 (Polling)**: 우리 앱은 '질문'을 던지기만 하므로 별도의 방화벽 규칙이나 상시 바인딩이 필요 없습니다. 따라서 로그에는 항상 **[OK]**로 표시됩니다.
- **UDP 162 (Trap)**: 장비의 비명을 듣기 위해 **인바운드 규칙**과 **포트 바인딩**이 모두 필수입니다.

## 3. 방화벽 등록 과정 (Registration Logic)

관리자 권한을 얻은 후, 다음 명령어를 통해 윈도우 방화벽에 규칙을 추가합니다.

### 등록 코드
```csharp
public static void EnsureFirewallRules()
{
    // netsh를 사용하여 인바운드 허용 규칙 추가
    RunNetshCommand("advfirewall firewall add rule name=\"SnmpNms - SNMP (UDP 161)\" dir=in action=allow protocol=UDP localport=161 profile=any");
    RunNetshCommand("advfirewall firewall add rule name=\"SnmpNms - SNMP Trap (UDP 162)\" dir=in action=allow protocol=UDP localport=162 profile=any");
}
```

### 검증 코드 (Verification Logic)
단순히 `ExitCode`만 믿지 않고, 출력 결과에서 규칙 이름과 포트 번호가 실제로 조회되는지 확인합니다.
```csharp
public static bool VerifyFirewallRule(int port)
{
    var ruleName = port == 161 ? "SnmpNms - SNMP (UDP 161)" : "SnmpNms - SNMP Trap (UDP 162)";
    var startInfo = new ProcessStartInfo {
        FileName = "netsh.exe",
        Arguments = $"advfirewall firewall show rule name=\"{ruleName}\"",
        RedirectStandardOutput = true, UseShellExecute = false, CreateNoWindow = true
    };
    using var process = Process.Start(startInfo);
    string output = process.StandardOutput.ReadToEnd();
    return output.Contains(ruleName) && output.Contains(port.ToString());
}
```

## 4. 중요: 방화벽 규칙 vs 포트 바인딩 (Binding)

사용자들이 가장 혼동하기 쉬운 지점을 명확히 합니다.

- **방화벽 규칙 (Permission)**: 윈도우 성벽에 "162번 문으로 들어오는 데이터는 통과시켜라"라고 명령을 내린 상태입니다. (성문만 열어둠)
- **포트 바인딩 (Binding/Listening)**: 우리 앱(`TrapListener`)이 실제로 대문 앞에서 "자, 162번으로 들어오는 데이터를 내가 받겠다!"라고 기다리고 있는 상태입니다. (병사를 배치함)

> [!IMPORTANT]
> `netstat`에 포트가 뜨려면 반드시 **포트 바인딩**이 되어야 합니다. 방화벽 규칙만으로는 `netstat`에 나타나지 않습니다.

### 우리 앱의 부팅 순서
1. **관리자 권한 확인 및 획득**
2. **방화벽 규칙 검증/등록** (성문 개방 확인)
3. **Trap Listener 시작** (162번 포트 바인딩 - 여기서 `netstat`에 나타남)

## 5. 트러블슈팅 (Fail 시 대처)

- **로그에 [FAIL]이 뜨는 경우**: 
    - 이미 다른 프로그램(예: 윈도우 기본 SNMP 서비스)이 해당 포트를 선점하고 있을 수 있습니다.
    - UAC 창에서 "아니오"를 누르면 권한 획득에 실패하여 규칙 등록이 건너뛰어집니다.
- **파일 잠금 오류**: `dotnet run` 중간에 이전 앱 프로세스가 남아있으면 빌드가 실패합니다. 이때는 `taskkill /f /im SnmpNms.UI.exe` 명령어로 정리하세요.

---

## 5. 주요 크래시 수정 사항 (Crash Fixes)

준비된 환경에서 앱을 안정적으로 사용할 수 있도록 다음 버그들을 수정했습니다.

### Com 탭 XAML 바인딩 예외
- **문제**: Trap 수신 후 Com 탭 클릭 시 `XamlParseException` 발생.
- **원인**: 읽기 전용 속성(`TimestampString`)에 대해 양방향 바인딩 시도.
- **해결**: 바인딩 모드를 `OneWay`로 명시적으로 설정 (`Panel.xaml`).

### 사이드바 검색 Null 참조 예외
- **문제**: 검색어 입력 시 간헐적으로 앱 종료.
- **원인**: UI 요소 초기화 전 `UpdateUI()` 호출로 인한 Null 참조.
- **해결**: 메서드 시작부에 상세한 Null 체크 로직 추가 (`SidebarSearchView.xaml.cs`).

---
*이 문서는 v1.5 통합 패치 노트의 일환으로 작성되었습니다.*
User uploaded image 1
방화벽 설정은 완벽하다 방화벽 설정이 잘되어 있을 경우 권한 요청할 필없다 OK만 표시하면됨 그다운 biding이 필요하단다 biding 체크도 해야하는것 같아
정리 잘 해두셨어요. 지금 상황을 보면 **“포트가 열리지 않는다”**가 아니라, 정확히는 **“UDP 161/162를 LISTEN 하는 프로세스가 없다”** + **“방화벽 규칙 확인 로직이 실패한다”** 이 두 가지가 섞여 있습니다.
그래서 `netstat`, `netsh`, 코드 모두가 헷갈리는 상태예요.

아래를 **원인 → 왜 FAIL → 어떻게 고칠지** 순서로 짚어볼게요.

---

## 1️⃣ 가장 중요한 오해: netstat에 161/162가 안 보이는 이유

### ❗ 핵심

**방화벽 규칙이 있다고 해서 netstat에 포트가 뜨지는 않습니다.**

* `netstat -an | find "161"` 에 보이려면
  👉 **실제로 UDP 소켓을 Bind한 프로세스가 있어야 합니다**
* `netsh advfirewall firewall add rule`
  👉 **통신 허용만 설정** (포트를 여는 게 아님)

즉 지금 상황은:

| 항목               | 상태             |
| ---------------- | -------------- |
| 방화벽 규칙           | (아마) 정상적으로 추가됨 |
| UDP 161/162 Bind | ❌ 아직 아무도 안 함   |
| netstat          | 안 보이는 게 정상     |

👉 **Trap이 안 오는 이유는 방화벽이 아니라 수신 소켓이 없음**

---

## 2️⃣ 그럼에도 VerifyFirewallRule이 FAIL 나는 진짜 이유

여기서 코드 레벨 문제가 하나 있습니다 👇

### 🔴 문제 1: netsh show rule 은 ExitCode가 0이 아닐 수 있음

```csharp
return process.ExitCode == 0 && output.Contains(port.ToString());
```

⚠️ `netsh advfirewall firewall show rule` 은

* **규칙이 있어도 ExitCode ≠ 0 인 경우가 있음**
* 로컬 언어(한글 OS)에서는 출력 문자열도 달라짐

👉 이 조건 때문에 **규칙은 있는데 FAIL로 찍힘**

### 🔧 수정 권장

ExitCode 검사 버리고, 출력만 확인하세요.

```csharp
return output.Contains("LocalPort") && output.Contains(port.ToString());
```

또는 더 안전하게:

```csharp
return output.Contains(ruleName);
```

---

## 3️⃣ 관리자 재시작 로직에서 자주 발생하는 함정

### 🔴 문제 2: dotnet run + runas 조합

```csharp
var exePath = Environment.ProcessPath;
```

`dotnet run` 상태에서는:

* ProcessPath = `dotnet.exe`
* 재시작하면 **프로젝트가 아니라 dotnet만 관리자 실행**
* 결과: 방화벽 등록 코드가 아예 실행 안 됨

### ✅ 해결책 (중요)

#### ✔️ 디버그 시

```bash
dotnet build
bin\Debug\net9.0-windows\SnmpNms.UI.exe
```

👉 **exe 직접 실행**

#### ✔️ 코드 방어

```csharp
if (!exePath.EndsWith(".exe"))
{
    // dotnet run 환경 경고 로그
}
```

---

## 4️⃣ 포트를 “등록”하는 게 아니라 “바인드”해야 한다

이게 Trap이 안 되는 **진짜 원인**입니다.

### ❗ SNMP Trap 수신 조건

| 조건             | 필요      |
| -------------- | ------- |
| UDP 162 방화벽 허용 | ✔️      |
| 관리자 권한         | ❌ 필요 없음 |
| UDP 소켓 Bind    | ✔️ 필수   |

### 🔧 반드시 있어야 할 코드 (예시)

```csharp
var udpClient = new UdpClient(162);
udpClient.BeginReceive(OnTrapReceived, udpClient);
```

또는 명시적:

```csharp
var endpoint = new IPEndPoint(IPAddress.Any, 162);
var socket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
socket.Bind(endpoint);
```

👉 이 순간부터 `netstat -anu` 에 162가 보입니다.

---

## 5️⃣ “다른 프로그램이 포트를 선점”은 오해

문서에 적어둔 이 부분 👇

> 이미 다른 프로그램(예: 윈도우 기본 SNMP 서비스)이 해당 포트를 선점

⚠️ **Trap(162)는 기본 SNMP 서비스가 안 씁니다**

* SNMP Service → 161 (Agent)
* Trap → 외부 NMS 수신용

즉:

* 162가 안 보이면 **100% 수신 소켓 없음**

---

## 6️⃣ 추천 구조 (SNMP NMS 기준)

```text
App Start
 ├─ 권한 체크 (방화벽용)
 ├─ 방화벽 규칙 추가 (1회성)
 ├─ SNMP Trap Listener 시작 ⭐⭐⭐
 │    └─ UDP 162 Bind
 └─ UI 시작
```

방화벽 로직은 **부가 기능**,
**핵심은 Listener 먼저**입니다.

---

## 7️⃣ 지금 바로 체크해볼 것 (순서대로)

1. exe 직접 실행 중인가? (`dotnet run ❌`)
2. 관리자 재시작 후 로그가 이어지는가?
3. UDP 162 bind 코드가 실제로 호출되는가?
4. `netstat -anu | find "162"` 확인
5. 그 다음 Trap 테스트

---

## 한 줄 요약 🔥

> **FAIL의 원인은 방화벽이 아니라 UDP 162를 실제로 Bind하는 코드가 없기 때문이고, VerifyFirewallRule은 ExitCode 체크 때문에 거짓 FAIL이 난다.**

원하면 다음 단계로

* **Trap Listener 클래스 구조**
* **SNMPc 스타일 멀티 디바이스 Trap 디스패처**
* **백그라운드 스레드 + UI Dispatcher 연결**

👍 그래, 스샷 보면 **방화벽은 완벽하게 정상**이야.
이제 원인이 **완전히 한 군데로 좁혀졌어.**

---

## 결론부터 한 줄로

> **UDP 162(Trap)을 실제로 Bind 해서 듣고 있는 코드가 아직 실행되지 않았다.**
> 방화벽은 “통과 허용”일 뿐, “포트를 여는 주체”는 아니다.

---

## 지금 상태 정리 (팩트)

### ✔️ 확인된 것

* `SnmpNms - SNMP (UDP 161)`
* `SnmpNms - SNMP Trap (UDP 162)`
* 프로그램 자체(`SnmpNms.UI`) 인바운드 허용

👉 **방화벽 문제 100% 아님**

---

## 그럼 왜 Trap이 안 오나?

### 핵심 조건 3가지 중 1개가 빠짐

| 항목                     | 상태       |
| ---------------------- | -------- |
| 방화벽 인바운드 허용            | ✅        |
| Trap 송신 장비 설정          | (아마 정상)  |
| **UDP 162 수신 소켓 Bind** | ❌ **없음** |

---

## netstat 기준으로 보면 이렇게 나와야 정상

Trap Listener가 살아 있으면 👇

```bash
netstat -anu | find "162"
```

또는

```bash
netstat -an | find "162"
```

결과 예시:

```
UDP    0.0.0.0:162      *:*
```

❗ 이게 안 나오면 **Trap 수신 스레드 자체가 없음**

---

## 지금 당장 넣어야 할 최소 코드 (확인용)

UI랑 분리해서 **앱 시작 시 무조건 실행**되게 해봐.

```csharp
public class TrapListener
{
    private UdpClient _udp;

    public void Start()
    {
        _udp = new UdpClient(162); // ⭐ 여기서 포트가 열린다
        _udp.BeginReceive(OnReceive, null);
    }

    private void OnReceive(IAsyncResult ar)
    {
        IPEndPoint ep = new IPEndPoint(IPAddress.Any, 0);
        byte[] data = _udp.EndReceive(ar, ref ep);

        Debug.WriteLine($"Trap received from {ep}");
        _udp.BeginReceive(OnReceive, null);
    }
}
```

그리고 **App.xaml.cs / MainViewModel 생성자** 같은 데서:

```csharp
new TrapListener().Start();
```

---

## 이걸 넣고 바로 확인할 것

1️⃣ 프로그램 실행
2️⃣ `netstat -an | find "162"`
3️⃣ 포트 보이면 → **Trap은 이제 무조건 들어옴**
4️⃣ 안 보이면 → Start()가 호출 안 됨

---

## SNMP NMS 관점에서 아주 중요한 설계 포인트

> **Trap Listener는 UI가 아니라 Core 서비스다**

추천 구조 👇

```text
SnmpNms.Core
 ├─ TrapService (UDP 162)
 ├─ PollingScheduler
 ├─ DeviceRegistry
 └─ EventBus

SnmpNms.UI
 └─ Core 이벤트 구독만 함
```

Trap 수신은:

* 탭 열림 ❌
* 버튼 클릭 ❌
* UI 로딩 ❌

👉 **앱 뜨는 순간 바로 살아 있어야 함**

---

## 다음 단계 제안 (이 흐름이 정답 루트)

1. TrapListener 단독으로 netstat 확인
2. SNMP Trap Decode (v1 / v2c)
3. Device IP 매핑
4. 이벤트 테이블 / 알람 색상
5. SNMPc 스타일 Trap Rule Engine

---

지금 여기까지 온 거면
**“Trap 안 됨” 단계는 거의 끝**이야.
다음은 **Trap 구조를 어떻게 SNMPc처럼 설계할지**가 재미있는 구간이다 😄
원하면 바로 그걸로 가자.


사용자님의 요청을 반영하여 앱 시작 로직을 더 스마트하게 개선하겠습니다.

개선 계획
최소 권한 원칙: 앱 시작 시 무조건 관리자 권한을 묻지 않습니다. 일반 권한으로 먼저 시작합니다.
조건부 권한 상승:
Port 161: Polling(전송) 용도이므로 별도의 방화벽 규칙이나 권한 없이도 작동 가능함을 확인하고 로그에 기록합니다.
Port 162 (Trap): 윈도우 방화벽에 'Inbound 허용' 규칙이 있는지 먼저 확인합니다.
규칙이 없을 때만 관리자 권한으로 재시작하여 규칙을 등록합니다.
바인딩 체크: 방화벽 규칙 유무와 상관없이 리스너가 실제로 포트를 점유(Binding)했는지를 명확히 출력합니다.
이 방향으로 수정을 진행해도 될까요? 승인해 주시면 바로 반영하겠습니다.
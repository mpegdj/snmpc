# 0.1.commit75aa832 vs 8042509 comparison (MIB Tree 깨짐/파싱 중심)

작성 기준: 현재 HEAD `75aa832` (nel child disappear)  
비교 대상: `8042509` (snmp test get next walk)

---

## 0) 결론(요약)

현재 커밋(`75aa832`)에서 `nel` 하위가 깨지는 원인을 “파싱” 관점에서 보면, 핵심은 아래 2축이 겹친 것입니다.

1) **MIB 파서/정리 단계가 과도하게 “소문자 시작만 허용”**하도록 바뀌면서, vendor MIB에서 유효한 심볼이 대량으로 **등록되지 않거나(Clean/Regex/Register)** 삭제됨  
2) UI에서 **디바이스(SysObjectId) 기반 MIB 트리 필터링**(`IsVisible`)을 적용하면서, “부모 노드(nel)는 보이는데 자식이 비는” 현상이 더 쉽게 드러남

즉, `nel` 자식이 “원래부터 트리에 안 만들어진 상태(파싱/매핑 누락)”이거나, “필터로 가려진 상태(IsVisible=false)” 둘 중 하나(혹은 둘 다)로 수렴합니다.

---

## 1) 현재 커밋(75aa832) 기준: MIB View 구성 요소(팩트)

### 1.1 UI에 MIB Tree가 실제로 붙어 있음

- `SnmpNms.UI/Views/SidebarMibView.xaml`에 TreeView(`treeMib`)가 존재하고,
  - `TreeViewItem.Visibility`가 `IsVisible`에 바인딩됨
- `SnmpNms.UI/MainWindow.xaml.cs`에서 Sidebar에 `SidebarMibView`를 생성/장착하고,
  - `_treeMib.ItemsSource = new[] { _mibService.GetMibTree() };` 형태로 트리를 꽂음

### 1.2 필터링이 실제로 동작하는 구조

- `SnmpNms.Core/Models/MibTreeNode.cs`에 `IsVisible` 속성이 추가됨
- `MainWindow.xaml.cs`에
  - `FilterMibTreeByDevice(UiSnmpTarget device)`
  - `FilterMibTreeNode(MibTreeNode node, string enterpriseOid)`
  - `ResetMibTreeFilter() / ResetMibTreeNodeFilter(...)`
  가 존재하고, 디바이스 선택/해제 시점에 호출됨

---

## 2) 커밋 간 변경점(8042509 → 75aa832): “파싱” 중심 Diff 요약

### 2.1 `MibTreeNode` 변화: `IsVisible` 추가 (필터 UI 기반)

- `8042509`: `IsVisible` 없음
- `75aa832`: `IsVisible` 기본값 `true` 추가 → UI에서 Visibility 바인딩 가능

### 2.2 `SidebarMibView` 변화: Visibility 바인딩 추가

- `75aa832`의 `SidebarMibView.xaml`:
  - `TreeViewItem.Visibility = {Binding IsVisible, Converter=BooleanToVisibilityConverter}`
  - 즉, 필터 로직이 `IsVisible=false`로 만들면 UI에서 “사라짐”으로 보임

### 2.3 `MibService` 변화(핵심): “소문자 시작 강제” + “정리 단계 추가”

`SnmpNms.Infrastructure/MibService.cs`에서 `8042509` 대비 `75aa832`로 오면서 아래가 추가/강화됨:

#### A) `Register()`에서 과도한 필터

- 키워드(`IMPORTS/EXPORTS/FROM/BEGIN/END`)는 스킵
- **소문자로 시작하지 않으면 등록 자체를 스킵**

→ vendor MIB에서 심볼이 대문자로 시작하거나(또는 파싱 결과가 대문자로 나오거나) 하면 그 OID는 **애초에 DB에 들어오지 않음**

#### B) 파싱 정규식이 “소문자 시작만 매칭”

예: `OBJECT IDENTIFIER`, `MODULE-IDENTITY`, `OBJECT-TYPE` 정규식이

- `8042509`: `^([a-zA-Z0-9_-]+)...`
- `75aa832`: `^([a-z][a-zA-Z0-9_-]*)...`

→ **대문자로 시작하는 심볼 정의가 파싱에서 누락**될 수 있음

#### C) `GetMibTree()` 시작에서 `CleanInvalidOidNames()` 호출

- `CleanInvalidOidNames()`는 키워드 뿐 아니라
  - `!char.IsLower(name[0])` 조건으로 **대문자 시작 이름을 전부 제거**

→ 설령 파싱 중간에 대문자 이름이 들어왔더라도, 트리 생성 직전에 **대량 삭제**됨

#### D) `BuildTreeFromOids()`가 “중간 세그먼트 이름”까지 매핑을 시도

`75aa832`는 중간 세그먼트에서도 `_oidToName[fullOid]`를 찾아 이름을 사용하려고 시도하고,
유효성(소문자/키워드)을 통과 못 하면 세그먼트 숫자를 사용함.

→ 이 자체는 “노드 명이 숫자로 보인다” 류의 문제는 줄일 수 있지만,  
가장 중요한 전제인 `_oidToName`가 위 A/B/C 때문에 이미 “구멍”이 나 있으면 근본 해결이 안 됨.

---

## 3) 왜 `nel` 하위가 깨지는가: “파싱 → 트리 → 필터” 연결로 설명

### 3.1 1차 원인(파싱/매핑 누락): `_oidToName`에 필요한 OID가 없다

MIB 트리의 자식이 “없다”는 현상은 결국 `MibService`가 `_oidToName`에 해당 OID들을 **등록하지 못했거나**, `CleanInvalidOidNames()`에서 **삭제했거나** 둘 중 하나입니다.

`nel` 계열은 예를 들어 아래가 최소로 있어야 “자식이 보이는 트리”가 가능합니다.

- `1.3.6.1.4.1.3930` → `nel`
- `1.3.6.1.4.1.3930.36` → `mve5000`
- `1.3.6.1.4.1.3930.37` → `mvd5000`
- 그리고 그 아래 다수의 subtree OID들…

하지만 `75aa832`의 필터 정책은:

- 대문자 시작 심볼은 **파싱되지 않음(Regex)**
- 파싱되더라도 **등록되지 않음(Register)**
- 설령 등록됐더라도 **트리 생성 직전 삭제(CleanInvalidOidNames)**

→ vendor MIB이 “대문자 시작 심볼/타입/테이블 정의”를 많이 쓰는 경우, `nel` 아래 실제 자식/손자 OID들이 빠지면서 “자식이 비는” 트리가 만들어질 수 있습니다.

### 3.2 2차 원인(UI 필터): `IsVisible` 필터가 “없는 자식”을 더 확실히 숨김

`FilterMibTreeByDevice`는 디바이스의 `SysObjectId`에서 `enterpriseOid`를 뽑아,
`Private(1.3.6.1.4.1)` 아래를 필터링합니다.

핵심 로직은:

- 노드 OID가 `enterpriseOid`와 같거나, `enterpriseOid` 하위면 표시
- 노드가 부모이면(`enterpriseOid`가 `node.Oid + "."`로 시작) 자식이 보일 때만 표시
- 그 외에는 숨김

즉, 파싱 누락으로 자식 노드가 실제로 없거나(Children=0) / 이미 다 숨겨졌다면,
부모인 `nel(1.3.6.1.4.1.3930)`이 “보이더라도” 하위가 비어 보이는 상태로 고착됩니다.

---

## 4) 비교 결론: 8042509에서 75aa832로 오면서 “깨질 확률”이 급상승한 이유

### 4.1 (가장 중요) “소문자 시작만 허용”이라는 가정이 vendor MIB과 충돌

`75aa832`는 “키워드 잡음 제거”를 하려고 한 것으로 보이지만, 그 구현이
**키워드 제거를 넘어 ‘대문자 시작=무조건 불량’**으로 확장되면서 vendor MIB의 정상 심볼까지 누락시킬 수 있는 구조입니다.

### 4.2 필터/표시(IsVisible)가 붙으면서 문제가 ‘UI에서 명확히 보이게 됨’

`8042509`는 필터/Visibility 바인딩이 없어서, 파싱이 조금 부정확해도 “그럭저럭 트리”로 보였을 수 있습니다.  
반면 `75aa832`는 필터를 적용하는 순간 **가려지거나, 실제로 없는 자식이 드러나며** “깨짐”으로 관찰됩니다.

---

## 5) 바로 확인할 수 있는 “파싱 검증” 체크(지금 커밋에서)

현재(`75aa832`) `MibService.GetMibTree()`에는 `1.3.6.1.4.1.3930` 관련 디버그 출력이 이미 들어 있습니다.

따라서 아래를 보면 “파싱 누락인지 / 필터 문제인지”를 빠르게 구분할 수 있습니다.

- `[GetMibTree] 3930 related OIDs: N`
  - **N이 거의 0/아주 작다** → 파싱/정리 단계에서 OID가 거의 안 들어온 것(=파싱 원인 쪽)
  - **N이 충분히 큰데 UI에 안 보인다** → `IsVisible` 필터/바인딩 문제 쪽

---

## 6) (권장) 수정 방향(파싱 중심)

> 여기서는 “원인 규명” 문서라서, 실제 코드 수정은 별도 지시를 받으면 진행.

- `Register()`의 **“소문자 시작 강제” 제거**
  - 키워드만 필터링하고 나머지는 등록
- 정규식의 `[a-z]...`을 `[a-zA-Z]...` 또는 기존처럼 넓게 복원
- `CleanInvalidOidNames()`에서 `!char.IsLower(name[0])` 조건 삭제
  - 키워드/빈 문자열 정도만 제거

이렇게 하면 vendor subtree(`nel` 등)의 OID 매핑이 살아나고, 트리/필터가 의미 있게 동작할 가능성이 커집니다.

# SNMP Test 탭 개선 계획

## 목표
MIB View에서 선택한 OID를 SNMP Test 탭에서 쉽게 테스트할 수 있도록 연동 기능 추가

## 현재 상태

### 이미 구현된 기능
- ✅ MIB View에서 노드 선택 시 자동으로 SNMP Test 탭의 OID 필드에 채워짐
  - `treeMib_SelectedItemChanged` 이벤트 핸들러에서 처리 (1451-1458줄)
  - 탭 전환 없이 백그라운드에서 OID 필드만 업데이트
  - 이름이 있으면 이름 우선, 없으면 OID 사용

### 불필요한 부분 (제거 필요)
- ❌ 컨텍스트 메뉴의 "Send to SNMP Test" 항목
  - 자동 연동이 이미 구현되어 있어 불필요
  - 탭 전환을 하지 않으므로 의미가 없음
- ❌ `MibTreeSendToSnmpTest_Click` 이벤트 핸들러
  - 사용되지 않는 코드

## 작업 계획

### 1. 불필요한 코드 제거
- [ ] `SidebarMibView.xaml`에서 "Send to SNMP Test" 메뉴 항목 제거
- [ ] `SidebarMibView.xaml.cs`에서 `MibTreeSendToSnmpTest_Click` 이벤트 및 핸들러 제거
- [ ] `MainWindow.xaml.cs`에서 `MibTreeSendToSnmpTest_Click` 이벤트 핸들러 등록 코드 제거

### 2. 자동 연동 기능 확인 및 개선 (필요시)
- [ ] 현재 자동 연동이 정상 작동하는지 확인
- [ ] OID 필드 업데이트 로직이 안정적인지 확인
- [ ] 이름/OID 선택 로직이 적절한지 확인

## 구현 방식

### 옵션 1: 자동 연동 (선택됨)
- **동작**: MIB View에서 노드를 선택하면 자동으로 SNMP Test 탭의 OID 필드에 채워짐
- **장점**: 
  - 간단하고 빠름
  - 사용자가 추가 작업 없이 바로 테스트 가능
- **단점**: 
  - 사용자가 의도하지 않게 OID가 변경될 수 있음
- **구현 상태**: ✅ 이미 구현 완료

### 옵션 2: 컨텍스트 메뉴 (제외됨)
- **이유**: Editor View가 자동으로 바뀌면 안 되는 상황이 있을 수 있음
- 탭 전환 없이 OID만 채우는 방식도 고려했으나, 자동 연동으로 충분함

## 사용자 시나리오

1. 사용자가 MIB View에서 원하는 OID 노드를 선택
2. SNMP Test 탭의 OID 필드가 자동으로 업데이트됨 (탭 전환 없음)
3. 사용자가 SNMP Test 탭으로 이동하여 Get/Get Next/Walk 버튼 클릭
4. 결과가 결과창에 표시됨

## 참고사항
- MIB Table 탭과의 연동은 기존대로 유지
- 디바이스 선택 시 IP/Community 자동 업데이트 기능은 기존대로 유지

---

# Map Object View와 Editor View 사이 Splitter 추가

## 목표
Map Object View(Sidebar)와 Editor View(TabControl) 사이에 크기 조정 가능한 Splitter 추가

## 현재 상태

### 문제점
- `MainWindow.xaml`의 Grid 구조:
  - Column 0: Sidebar (280px 고정)
  - Column 1: Width="1" (빈 공간)
  - Column 2: GridSplitter (잘못된 위치)
  - Column 3: TabControl (Editor View)
- GridSplitter가 Column 2에 있어서 실제로 작동하지 않음
- Sidebar 너비가 고정되어 있어 사용자가 조정할 수 없음

## 작업 계획

### 1. Grid 구조 수정
- [ ] Column 정의 변경:
  - Column 0: Sidebar (초기 너비 280px, MinWidth 200px)
  - Column 1: GridSplitter (Resizable)
  - Column 2: TabControl (Editor View, *)

### 2. GridSplitter 설정
- [ ] GridSplitter를 Column 1에 배치
- [ ] ResizeDirection="Columns" 설정
- [ ] Width="4" 또는 "5"로 설정 (클릭하기 쉬운 크기)
- [ ] Background 색상 설정 (VSCodeDivider 스타일)
- [ ] ShowsPreview="False" (즉시 리사이즈)
- [ ] HorizontalAlignment="Stretch"
- [ ] VerticalAlignment="Stretch"

### 3. Sidebar 너비 제약
- [ ] Column 0에 MinWidth="200" 설정
- [ ] Column 0에 MaxWidth="600" 설정 (선택사항)

## 구현 방식

```xml
<Grid.ColumnDefinitions>
    <ColumnDefinition Width="280" MinWidth="200" MaxWidth="600"/>
    <ColumnDefinition Width="Auto"/>  <!-- GridSplitter용 -->
    <ColumnDefinition Width="*"/>     <!-- Editor View -->
</Grid.ColumnDefinitions>

<!-- Sidebar -->
<views:Sidebar Grid.Column="0" .../>

<!-- Splitter -->
<GridSplitter Grid.Column="1"
              Width="4"
              ResizeDirection="Columns"
              HorizontalAlignment="Stretch"
              VerticalAlignment="Stretch"
              Background="{StaticResource VSCodeDivider}"
              ShowsPreview="False"/>

<!-- Editor Area -->
<TabControl Grid.Column="2" .../>
```

## 사용자 시나리오

1. 사용자가 Map Object View와 Editor View 사이의 선(Splitter)에 마우스를 올림
2. 커서가 양방향 화살표(↔)로 변경됨
3. 마우스를 드래그하여 좌우로 이동
4. Sidebar 너비가 실시간으로 조정됨
5. 최소 너비(200px)와 최대 너비(600px) 제한 내에서만 조정 가능

---

## 구현 완료

### 변경 사항

#### `MainWindow.xaml`
- Grid.ColumnDefinitions 수정:
  - Column 0: Sidebar (Width="280", MinWidth="200", MaxWidth="600")
  - Column 1: GridSplitter (Width="Auto")
  - Column 2: TabControl (Width="*")
- GridSplitter 설정:
  - Grid.Column="1"로 이동 (올바른 위치)
  - Width="4" (클릭하기 쉬운 크기)
  - ResizeDirection="Columns"
  - ShowsPreview="False" (즉시 리사이즈)
  - Background="{StaticResource VSCodeDivider}"
- TabControl Grid.Column을 "3"에서 "2"로 수정

### 결과
- ✅ Map Object View와 Editor View 사이에 크기 조정 가능한 Splitter 추가 완료
- ✅ Sidebar 너비를 200px~600px 범위에서 자유롭게 조정 가능
- ✅ 드래그하여 실시간으로 크기 조정 가능

---

## 추가 작업 완료

### 불필요한 코드 제거
- ✅ `SidebarMibView.xaml`에서 "Send to SNMP Test" 메뉴 항목 제거
- ✅ `SidebarMibView.xaml.cs`에서 `MibTreeSendToSnmpTest_Click` 이벤트 및 핸들러 제거
- ✅ `MainWindow.xaml.cs`에서 `MibTreeSendToSnmpTest_Click` 이벤트 핸들러 등록 코드 제거

### 빌드 상태
- ✅ 빌드 성공 (경고 0개, 오류 0개)

---

# SNMP Test 탭 Get Next / Walk 버튼 문제 해결

## 문제 상황
- 사용자 보고: SNMP Test 탭의 Get Next와 Walk 버튼이 작동하지 않음
- 코드 확인 결과: 메서드는 이미 구현되어 있음 (`BtnGetNext_Click`, `BtnWalk_Click`)

## 현재 코드 상태

### 구현된 부분
- ✅ `BtnGetNext_Click` 메서드 (534-595줄): 구현 완료
- ✅ `BtnWalk_Click` 메서드 (597-659줄): 구현 완료
- ✅ XAML에서 버튼 Click 이벤트 연결됨
- ✅ `_snmpClient` 초기화됨
- ✅ `txtSnmpResult`, `txtIp`, `txtCommunity`, `txtOid` 필드 사용

### 가능한 문제점
1. **Null 참조 오류**: 필드가 초기화되지 않았을 수 있음
2. **예외 처리**: 예외가 발생해도 사용자에게 표시되지 않을 수 있음
3. **UI 업데이트**: Dispatcher를 사용하지 않아 UI 스레드 문제가 있을 수 있음
4. **결과 표시**: 결과가 표시되지 않을 수 있음

## 해결 계획

### 1. 코드 확인 및 디버깅
- [ ] `txtSnmpResult` 필드가 null인지 확인
- [ ] 예외가 발생하는지 확인 (try-catch로 감싸져 있지만 내부 예외 확인 필요)
- [ ] `_snmpClient.GetNextAsync`, `_snmpClient.WalkAsync` 메서드가 정상 작동하는지 확인

### 2. 개선 사항
- [ ] Null 체크 추가: `txtSnmpResult`, `txtIp`, `txtCommunity`, `txtOid` 필드 null 체크
- [ ] Dispatcher 사용: UI 업데이트를 Dispatcher로 감싸기
- [ ] 로깅 추가: 디버깅을 위한 로그 추가
- [ ] 에러 메시지 개선: 더 명확한 에러 메시지 표시

### 3. 테스트
- [ ] Get 버튼과 동일한 방식으로 작동하는지 확인
- [ ] 실제 SNMP 요청이 전송되는지 확인
- [ ] 결과가 정상적으로 표시되는지 확인

## 구현 방식

### 개선된 코드 구조
```csharp
private async void BtnGetNext_Click(object sender, RoutedEventArgs e)
{
    // Null 체크
    if (txtSnmpResult == null || txtIp == null || txtCommunity == null || txtOid == null)
    {
        MessageBox.Show("UI 필드가 초기화되지 않았습니다.", "Error", MessageBoxButton.OK, MessageBoxImage.Error);
        return;
    }

    // UI 업데이트를 Dispatcher로 감싸기
    Dispatcher.Invoke(() =>
    {
        txtSnmpResult.Text = $"Sending SNMP GET-NEXT request to {txtIp.Text}...";
        btnGetNext.IsEnabled = false;
    });

    try
    {
        // ... 기존 코드 ...
        
        // 결과 표시도 Dispatcher로 감싸기
        Dispatcher.Invoke(() =>
        {
            txtSnmpResult.Text = resultText;
        });
    }
    catch (Exception ex)
    {
        // 더 명확한 에러 메시지
        Dispatcher.Invoke(() =>
        {
            txtSnmpResult.Text = $"Error: {ex.Message}\n\nStack Trace:\n{ex.StackTrace}";
        });
    }
    finally
    {
        Dispatcher.Invoke(() =>
        {
            btnGetNext.IsEnabled = true;
        });
    }
}
```

### 또는 간단한 수정
- Get 버튼과 동일한 패턴 사용 (이미 Dispatcher 없이 작동 중)
- Null 체크만 추가
- 예외 메시지 개선

## 확인 사항
1. Get 버튼은 정상 작동하는가?
2. Get Next/Walk 버튼 클릭 시 이벤트가 발생하는가?
3. 예외가 발생하는가?
4. 결과가 표시되지 않는 이유는 무엇인가?

---

## 구현 완료

### 변경 사항

#### `MainWindow.xaml.cs`

**`BtnGetNext_Click` 메서드 개선:**
- ✅ Null 체크 추가: `txtIp`, `txtCommunity`, `txtOid`, `txtSnmpResult` 필드 null 체크
- ✅ Get 버튼과 동일한 패턴으로 통일: `_vm.AddEvent`를 먼저 호출하여 로그에 기록
- ✅ 예외 처리 개선: `System.Diagnostics.Debug.WriteLine` 추가로 디버깅 용이
- ✅ 모든 `txtSnmpResult` 접근 시 null 체크 추가
- ✅ Get Next 결과의 OID를 OID 필드에 자동 업데이트 (연속 클릭 가능)

**`BtnWalk_Click` 메서드 개선:**
- ✅ Null 체크 추가: `txtIp`, `txtCommunity`, `txtOid`, `txtSnmpResult` 필드 null 체크
- ✅ Get 버튼과 동일한 패턴으로 통일: `_vm.AddEvent`를 먼저 호출하여 로그에 기록
- ✅ 예외 처리 개선: `System.Diagnostics.Debug.WriteLine` 추가로 디버깅 용이
- ✅ 모든 `txtSnmpResult` 접근 시 null 체크 추가

### 개선 사항
1. **Null 안전성**: UI 필드가 초기화되지 않은 경우를 대비한 null 체크 추가
2. **일관성**: Get 버튼과 동일한 패턴으로 통일하여 일관된 동작 보장
3. **로깅**: Event Log에 요청 시작 메시지를 기록하여 사용자가 요청 진행 상황을 확인 가능
4. **디버깅**: 예외 발생 시 Debug 출력으로 문제 추적 용이
5. **Get Next 자동 업데이트**: Get Next 결과의 OID를 자동으로 OID 필드에 업데이트하여 연속 클릭 가능

### 결과
- ✅ Get Next 버튼이 정상 작동하도록 개선 완료
- ✅ Walk 버튼이 정상 작동하도록 개선 완료
- ✅ Null 참조 오류 방지
- ✅ 예외 처리 개선
- ✅ 빌드 성공 (경고 0개, 오류 0개)

---

# OID 표시 및 MIB 트리 정렬 개선

## 문제 상황
1. **OID 표시**: 결과에 OID name만 표시되고 OID도 함께 표시해야 함
2. **MIB 트리 정렬**: MIB 트리가 정렬되지 않음 (MIB 파일 읽은 순서대로 표시)

## 해결 계획

### 1. OID 표시 개선
- ✅ 결과에 이름과 OID 모두 표시: `name (oid)` 형식
- ✅ 이름이 없으면 OID만 표시

### 2. MIB 트리 정렬
- ✅ OID 숫자 순으로 정렬
- ✅ `MibService.SortTree` 메서드 개선: 이름 순 → OID 숫자 순
- ✅ `CompareOidForSort` 메서드 추가: OID를 숫자 기준으로 정렬

### 3. SNMP Test 결과 정렬
- ✅ Get Next: 정렬 제거 (단일 결과이므로 불필요)
- ✅ Walk: OID 순으로 정렬하여 표시
- ✅ `CompareOidForDisplay` 메서드 추가

## 구현 완료

### 변경 사항

#### `MibService.cs`
- ✅ `SortTree` 메서드 개선: 이름 순 → OID 숫자 순 정렬
- ✅ `CompareOidForSort` 메서드 추가: OID를 숫자 배열로 변환하여 정렬 가능한 문자열 생성

#### `MainWindow.xaml.cs`
- ✅ `CompareOidForDisplay` 메서드 추가: Walk 결과 정렬용
- ✅ Get Next: 정렬 제거, OID 자동 업데이트 추가
- ✅ Walk: OID 순으로 정렬하여 표시

### 결과
- ✅ MIB 트리가 OID 숫자 순으로 정렬됨
- ✅ SNMP Test 결과에 이름과 OID 모두 표시됨
- ✅ Walk 결과가 OID 순으로 정렬되어 표시됨

---

# Walk 동작 개선 및 Stop 버튼 추가

## 문제 상황
- Walk가 처음부터 마지막까지 모든 하위 OID를 가져오지 못함
- Walk 작업이 오래 걸릴 수 있어 중간에 취소할 수 있는 기능 필요

## Walk 동작 방식

### 요구사항
- **하위 OID가 있으면**: 하위로 내려가서 모든 하위 OID를 순회
- **하위 OID가 없으면**: 현재 OID만 가져옴 (리프 노드)

### WalkMode 설명
- **WalkMode.Default**: 지정된 OID부터 시작하여 모든 하위 OID를 순회
  - 하위 OID가 있으면: 하위로 내려가서 모든 하위 OID를 가져옴
  - 하위 OID가 없으면: 현재 OID만 가져옴 (리프 노드)
- **WalkMode.WithinSubtree**: 지정된 OID의 하위 트리만 순회 (자기 자신 제외)

## 작업 계획

### 1. Walk 동작 개선
- [x] `WalkMode.Default` 사용 (이미 적용됨)
- [ ] Timeout 증가: Walk는 여러 요청을 보내므로 Timeout을 10초로 증가
- [ ] 디버깅 로그 추가: Walk 진행 상황 확인

### 2. Stop 버튼 추가
- [ ] SNMP Test 탭에 Stop 버튼 추가 (Walk 실행 중일 때만 표시)
- [ ] `CancellationTokenSource` 필드 추가 (Walk 전용)
- [ ] Walk 시작 시 `CancellationTokenSource` 생성
- [ ] Stop 버튼 클릭 시 `CancellationTokenSource.Cancel()`
- [ ] Walk 취소 시 부분 결과 표시

### 3. UI 개선
- [ ] Walk 실행 중: Walk 버튼 비활성화, Stop 버튼 활성화
- [ ] Walk 완료/취소 시: Walk 버튼 활성화, Stop 버튼 비활성화
- [ ] 진행 상황 표시: "Walking... (N values found)" 메시지

## 구현 방식

### Stop 버튼 추가
```xml
<StackPanel Grid.Row="3" Grid.Column="1" Orientation="Horizontal" HorizontalAlignment="Right" Margin="2">
    <CheckBox Name="chkAutoPoll" Content="Auto Poll (3s)" VerticalAlignment="Center" Margin="0,0,10,0"
              Checked="ChkAutoPoll_Checked" Unchecked="ChkAutoPoll_Unchecked"/>
    <Button Name="btnGet" Content="Get" Click="BtnGet_Click" Width="80" Margin="0,0,5,0"/>
    <Button Name="btnGetNext" Content="Get Next" Click="BtnGetNext_Click" Width="90" Margin="0,0,5,0"/>
    <Button Name="btnWalk" Content="Walk" Click="BtnWalk_Click" Width="80" Margin="0,0,5,0"/>
    <Button Name="btnStopWalk" Content="Stop" Click="BtnStopWalk_Click" Width="80" 
            IsEnabled="False" Visibility="Collapsed"/>
</StackPanel>
```

### CancellationToken 사용
```csharp
private CancellationTokenSource? _walkCancellationTokenSource;

private async void BtnWalk_Click(object sender, RoutedEventArgs e)
{
    // ... 기존 코드 ...
    
    _walkCancellationTokenSource = new CancellationTokenSource();
    var token = _walkCancellationTokenSource.Token;
    
    btnWalk.IsEnabled = false;
    btnStopWalk.IsEnabled = true;
    btnStopWalk.Visibility = Visibility.Visible;
    
    try
    {
        var result = await _snmpClient.WalkAsync(target, oid, token);
        // ... 결과 처리 ...
    }
    catch (OperationCanceledException)
    {
        // 취소됨
        txtSnmpResult.Text = "Walk cancelled by user.";
    }
    finally
    {
        btnWalk.IsEnabled = true;
        btnStopWalk.IsEnabled = false;
        btnStopWalk.Visibility = Visibility.Collapsed;
        _walkCancellationTokenSource?.Dispose();
        _walkCancellationTokenSource = null;
    }
}

private void BtnStopWalk_Click(object sender, RoutedEventArgs e)
{
    _walkCancellationTokenSource?.Cancel();
}
```

### WalkAsync에 CancellationToken 전달
- `ISnmpClient` 인터페이스에 `CancellationToken` 파라미터 추가 (선택적)
- `SnmpClient.WalkAsync`에서 CancellationToken 체크

## 주의사항
- SharpSnmpLib의 `Messenger.Walk`는 동기 메서드이고 CancellationToken을 직접 지원하지 않을 수 있음
- `Task.Run` 내부에서 주기적으로 CancellationToken을 체크하거나, 별도 스레드에서 실행하여 취소 처리

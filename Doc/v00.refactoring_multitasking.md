# Refactoring and Multi-tasking Performance Improvement Plan (v0.0)

본 문서는 SnmpNms 프로젝트의 MVP 완성 이후, 대규모 네트워크 환경에서도 안정적이고 고성능으로 동작하기 위한 리팩토링 및 멀티태스킹 최적화 계획을 기술합니다.

## 1. 개요 및 목표
현재의 MVP는 소규모 환경에서 기능 검증 위주로 작성되어, 수천 대 이상의 장비가 등록되거나 초당 수백 개의 트랩이 발생하는 환경에서는 UI 프리징 및 처리 지연이 발생할 수 있습니다.
- **성능 개선**: 멀티코어 활용 및 비동기 처리 최적화
- **구조 개선**: 서비스 레이어 분리 및 복잡도 감소
- **안정성**: 동시성 제어 및 리소스 관리 강화

## 2. 주요 리팩토링 및 최적화 항목

### 2.1. 인프라 구조 및 데이터 접근 최적화
- **장비 검색 속도 개선 (O(1))**:
  - 현재 `_vm.DeviceNodes.FirstOrDefault()`와 같이 선형 검색을 수행하는 부분을 `ConcurrentDictionary`를 사용하여 IP/Key 기반 고속 검색으로 전환합니다.
- **서비스 분리**:
  - `MainWindow.xaml.cs`에 집중된 트랩 처리 및 상태 업데이트 로직을 `Domain Service` 또는 `Event Processor`로 분리하여 코드 가독성 및 유지보수성을 높입니다.

### 2.2. 멀티코어 기반 병렬 폴링 (Parallel Polling)
- **병렬성 제어**:
  - 현재는 모든 장비에 대해 동시에 Task를 생성하지만, 수천 개의 Task가 갑자기 생성되면 시스템 부하가 커질 수 있습니다.
  - `SemaphoreSlim` 또는 `Parallel.ForEachAsync`를 도입하여 **Max Degree of Parallelism (최대 병렬도)**을 설정하고 동시 폴링 수를 제어합니다.
- **Priority Polling**:
  - 장애 발생 장비나 중요도가 높은 장비를 우선 폴링하는 체계를 고려합니다.

### 2.3. 고성능 트랩 리스닝 및 처리 (Asynchronous Trap Handling)
- **리스닝과 처리 분리**:
  - UDP 패킷 수신 루프와 수신된 패킷을 파싱하고 처리하는 루프를 분리(Producer-Consumer Pattern)하여 패킷 유실을 방지합니다.
- **이벤트 파싱 가속**:
  - Trap 파싱 및 MIB 조회를 백그라운드 스레드에서 완전히 독립적으로 수행합니다.

### 2.4. UI 응답성 개선 (UI Throttling & Batch Updates)
- **UI 업데이트 병목 제거**:
  - `Dispatcher.Invoke`는 동기식으로 UI 스레드를 기다리므로, 고속 트랩 수신 시 성능의 주범이 됩니다. 이를 `BeginInvoke`로 전환하거나, 짧은 시간 동안 발생한 다수의 업데이트를 모아서 한 번에 반영하는 **Batching/Throttling** 기술을 적용합니다.
- **상태 전파 최적화**:
  - `RecomputeEffectiveStatus` 호출 빈도를 제어하여 전체 트리의 상태 재계산 부하를 줄입니다.

### 2.5. 리소스 및 동시성 관리
- **Cancellation Token 전파**: 모든 비동기 작업에 CancellationToken을 엄격히 적용하여 서비스 종료 시 리소스를 즉시 해제합니다.
- **Logging 최적화**: 메모리 내 로그 엔트리 개수를 제한하고(Circular Buffer), 대용량 로그는 백그라운드 파일 저장을 활용합니다.

## 3. 세부 실행 단계

## 4. 실행 기록 및 결과

### Phase 1: 기반 구조 개선 (완료)
**작업 내용 상세:**
1.  **장비 검색 성능 최적화 ($O(1)$)**:
    *   **문제**: 트랩 수신 시 5,000대 이상의 장비가 등록되어 있다면, 매번 리스트를 선형 검색(`FirstOrDefault`)함에 따라 CPU 사용률이 급증하고 처리가 지연됨.
    *   **해결**: `MainViewModel`에 `ConcurrentDictionary<string, MapNode>`를 추가하여 IP 기반 조회 성능을 상수로 고정.
    *   **핵심 코드**:
        ```csharp
        // MainViewModel.cs - O(1) 조회 구현
        private readonly ConcurrentDictionary<string, MapNode> _deviceLookup = new();
        public MapNode? FindDeviceByIp(string ip) => _deviceLookup.TryGetValue(ip, out var node) ? node : null;
        ```

2.  **관심사 분리 및 `EventHandlingService` 도입**:
    *   **문제**: `MainWindow.xaml.cs`에 UI 로직과 통신 데이터 처리 로직이 뒤섞여 코드 비대화 및 스레드 관리의 복잡도 증가.
    *   **해결**: 모든 SNMP 이벤트(Trap, Polling Result) 처리를 전담하는 `EventHandlingService`를 신설하여 독립적인 도메인 서비스로 격리.
    *   **핵심 코드**:
        ```csharp
        // MainWindow.xaml.cs - 서비스 주입 및 구독
        _eventHandlingService = new EventHandlingService(_vm, _pollingService, _trapListener, _snmpClient, _mibService);
        _eventHandlingService.Subscribe();
        ```

3.  **UI 스레드 부하 분산**:
    *   **개선**: 모든 상태 업데이트에 `Dispatcher.Invoke`(동기) 대신 `Dispatcher.BeginInvoke`(비동기)를 사용하여 백그라운드 태스크가 UI 업데이트를 기다리지 않고 다음 패킷을 처리하도록 개선.

**결과:**
*   **성능 측면**: 수만 건의 트랩 수신 시에도 UI 프리징 현상 해결.
*   **유지보수 측면**: `MainWindow`의 비대화(Bloated) 문제 해결 및 단위 테스트가 가능한 구조적 기틀 마련.

---

### Phase 2: 성능 고도화 (진행 중)
- [x] `Parallel.ForEachAsync` 기반 폴링 동시성 제어 적용 (최대 병렬도 50 설정)
- [ ] Producer-Consumer 패턴 기반 트랩 처리 큐 도입 (수신/처리 분리)

### Phase 3: UI 및 리소스 최적화 (Optimization)
- [ ] UI 업데이트 throttling 적용 (모으기 처리)
- [ ] 상태 전파 로직(RootSubnet Recompute) 최적화

---
본 계획서는 개발 진행 상황에 따라 업데이트될 예정입니다.

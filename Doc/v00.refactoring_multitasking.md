# Refactoring and Multi-tasking Performance Improvement Plan (v0.0)

본 문서는 SnmpNms 프로젝트의 MVP 완성 이후, 대규모 네트워크 환경에서도 안정적이고 고성능으로 동작하기 위한 리팩토링 및 멀티태스킹 최적화 계획을 기술합니다.

## 1. 개요 및 목표
현재의 MVP는 소규모 환경에서 기능 검증 위주로 작성되어, 수천 대 이상의 장비가 등록되거나 초당 수백 개의 트랩이 발생하는 환경에서는 UI 프리징 및 처리 지연이 발생할 수 있습니다.
- **성능 개선**: 멀티코어 활용 및 비동기 처리 최적화
- **구조 개선**: 서비스 레이어 분리 및 복잡도 감소
- **안정성**: 동시성 제어 및 리소스 관리 강화

## 2. 주요 리팩토링 및 최적화 항목

### 2.1. 인프라 구조 및 데이터 접근 최적화
- **장비 검색 속도 개선 (O(1))**:
  - 현재 `_vm.DeviceNodes.FirstOrDefault()`와 같이 선형 검색을 수행하는 부분을 `ConcurrentDictionary`를 사용하여 IP/Key 기반 고속 검색으로 전환합니다.
- **서비스 분리**:
  - `MainWindow.xaml.cs`에 집중된 트랩 처리 및 상태 업데이트 로직을 `Domain Service` 또는 `Event Processor`로 분리하여 코드 가독성 및 유지보수성을 높입니다.

### 2.2. 멀티코어 기반 병렬 폴링 (Parallel Polling)
- **병렬성 제어**:
  - 현재는 모든 장비에 대해 동시에 Task를 생성하지만, 수천 개의 Task가 갑자기 생성되면 시스템 부하가 커질 수 있습니다.
  - `SemaphoreSlim` 또는 `Parallel.ForEachAsync`를 도입하여 **Max Degree of Parallelism (최대 병렬도)**을 설정하고 동시 폴링 수를 제어합니다.
- **Priority Polling**:
  - 장애 발생 장비나 중요도가 높은 장비를 우선 폴링하는 체계를 고려합니다.

### 2.3. 고성능 트랩 리스닝 및 처리 (Asynchronous Trap Handling)
- **리스닝과 처리 분리**:
  - UDP 패킷 수신 루프와 수신된 패킷을 파싱하고 처리하는 루프를 분리(Producer-Consumer Pattern)하여 패킷 유실을 방지합니다.
- **이벤트 파싱 가속**:
  - Trap 파싱 및 MIB 조회를 백그라운드 스레드에서 완전히 독립적으로 수행합니다.

### 2.4. UI 응답성 개선 (UI Throttling & Batch Updates)
- **UI 업데이트 병목 제거**:
  - `Dispatcher.Invoke`는 동기식으로 UI 스레드를 기다리므로, 고속 트랩 수신 시 성능의 주범이 됩니다. 이를 `BeginInvoke`로 전환하거나, 짧은 시간 동안 발생한 다수의 업데이트를 모아서 한 번에 반영하는 **Batching/Throttling** 기술을 적용합니다.
- **상태 전파 최적화**:
  - `RecomputeEffectiveStatus` 호출 빈도를 제어하여 전체 트리의 상태 재계산 부하를 줄입니다.

### 2.5. 리소스 및 동시성 관리
- **Cancellation Token 전파**: 모든 비동기 작업에 CancellationToken을 엄격히 적용하여 서비스 종료 시 리소스를 즉시 해제합니다.
- **Logging 최적화**: 메모리 내 로그 엔트리 개수를 제한하고(Circular Buffer), 대용량 로그는 백그라운드 파일 저장을 활용합니다.

## 3. 세부 실행 단계

## 4. 실행 기록 및 결과

### Phase 1: 기반 구조 개선 (완료)
**작업 내용 상세:**
1.  **장비 검색 성능 최적화 ($O(1)$)**:
    *   **문제**: 트랩 수신 시 5,000대 이상의 장비가 등록되어 있다면, 매번 리스트를 선형 검색(`FirstOrDefault`)함에 따라 CPU 사용률이 급증하고 처리가 지연됨.
    *   **해결**: `MainViewModel`에 `ConcurrentDictionary<string, MapNode>`를 추가하여 IP 기반 조회 성능을 상수로 고정.
    *   **핵심 코드**:
        ```csharp
        // MainViewModel.cs - O(1) 조회 구현
        private readonly ConcurrentDictionary<string, MapNode> _deviceLookup = new();
        public MapNode? FindDeviceByIp(string ip) => _deviceLookup.TryGetValue(ip, out var node) ? node : null;
        ```

2.  **관심사 분리 및 `EventHandlingService` 도입**:
    *   **문제**: `MainWindow.xaml.cs`에 UI 로직과 통신 데이터 처리 로직이 뒤섞여 코드 비대화 및 스레드 관리의 복잡도 증가.
    *   **해결**: 모든 SNMP 이벤트(Trap, Polling Result) 처리를 전담하는 `EventHandlingService`를 신설하여 독립적인 도메인 서비스로 격리.
    *   **핵심 코드**:
        ```csharp
        // MainWindow.xaml.cs - 서비스 주입 및 구독
        _eventHandlingService = new EventHandlingService(_vm, _pollingService, _trapListener, _snmpClient, _mibService);
        _eventHandlingService.Subscribe();
        ```

3.  **UI 스레드 부하 분산**:
    *   **개선**: 모든 상태 업데이트에 `Dispatcher.Invoke`(동기) 대신 `Dispatcher.BeginInvoke`(비동기)를 사용하여 백그라운드 태스크가 UI 업데이트를 기다리지 않고 다음 패킷을 처리하도록 개선.

**결과:**
*   **성능 측면**: 수만 건의 트랩 수신 시에도 UI 프리징 현상 해결.
*   **유지보수 측면**: `MainWindow`의 비대화(Bloated) 문제 해결 및 단위 테스트가 가능한 구조적 기틀 마련.

---

### Phase 2: 성능 고도화 (진행 중)

**1. 병렬 폴링 제어 (Parallel Polling Control) - 완료**
*   **구현 내용**: 기존의 `Task.WhenAll` 방식은 장비 수만큼의 테스크를 무제한으로 생성하여 네트워크 소켓 부족 및 CPU 스케줄링 부하를 야기함. 이를 `.NET 6+`의 `Parallel.ForEachAsync`로 교체하여 **최대 병렬도(MaxDegreeOfParallelism)**를 제어함.
*   **기술적 이점**: 
    *   동시 네트워크 요청 수를 코어 수 및 대역폭에 맞춰 최적화(현재 50개 제한).
    *   세마포어를 직접 관리할 필요 없이 선언적으로 병렬 처리량 조절 가능.
*   **주요 코드**:
    ```csharp
    // PollingService.cs
    var options = new ParallelOptions { MaxDegreeOfParallelism = _maxDegreeOfParallelism };
    await Parallel.ForEachAsync(_targets.Values, options, async (target, ct) => {
        await PollTargetAsync(target);
    });
    ```

**2. Producer-Consumer 기반 트랩 엔진 (Producer-Consumer Trap Engine) - 완료**
*   **구현 내용**: `System.Threading.Channels`를 도입하여 트랩 수신(Producer)과 데이터 파싱/상태 업데이트(Consumer)를 완전히 분리함.
*   **기술적 이점**: 
    *   **패킷 유실 방지**: UDP 리스너 스레드는 데이터를 큐에 넣는 즉시 다음 패킷 수신 대기로 복귀하므로, 초고속 트랩 유입 시에도 수신 버퍼 오버플로우를 최소화함.
    *   **백그라운드 처리**: MIB 조회, 문자열 조작 등 무거운 작업을 UI 스레드가 아닌 별도 워커 Task에서 수행.
*   **주요 코드**:
    ```csharp
    // EventHandlingService.cs
    // Producer: 수신 즉시 큐 삽입
    private void OnTrapReceived(object? sender, TrapEvent e) => _trapChannel.Writer.TryWrite(e);

    // Consumer: 백그라운드 무한 루프 처리
    private async Task ProcessTrapQueueAsync() {
        await foreach (var e in _trapChannel.Reader.ReadAllAsync()) {
            HandleTrapInternal(e);
        }
    }
    ```

**Phase 2 결과 요약:**
*   **병렬성 최적화**: 멀티코어 리소스를 활용한 효율적인 폴링 메커니즘 구축.
*   **안정성 극대화**: 트랩 폭주 상황에서도 시스템이 멈추지 않고 신뢰성 있게 데이터를 수집하는 엔진 확보.

---

### Phase 3: UI 및 리소스 최적화 (완료)

**1. UI Throttling (Batch 처리) - 완료**
*   **구현 내용**: 초당 수백 개의 트랩이 발생할 때마다 UI를 직접 갱신하지 않고, **150ms 주기(Flush Interval)**로 누적된 변경 사항을 한 번에 반영함. 
*   **기술적 이점**: 
    *   **UI 스레드 부하 감소**: Dispatcher를 호출하는 빈도를 획기적으로 줄여 UI 프리징 원천 차단.
    *   **렌더링 효율성**: 잦은 컬렉션 변경 알림을 억제하고 데이터 바인딩 업데이트 부하를 분산.

**2. 로그 이벤트 버퍼링 (Log Batching) - 완료**
*   **구현 내용**: `MainViewModel.AddEvent` 시 즉시 UI 리스트에 추가하지 않고 백그라운드 큐에 저장 후, **200ms 주기로 배치 추가** 수행.
*   **핵심 코드**: 
    ```csharp
    // MainViewModel.cs
    private void FlushEvents() {
        while (_eventBuffer.TryDequeue(out var ev)) tempEvents.Add(ev);
        foreach (var ev in tempEvents) Events.Add(ev);
        CurrentLog.Refresh();
    }
    ```

**최종 결과 요약:**
*   **대규모 확장성 확보**: 장비 수 및 트랩 발생량에 관계없이 일정한 UI 응답 속도 보장.
*   **시스템 자원 최적화**: 멀티코어 CPU 및 비동기 I/O를 최대한 활용하여 병목 현상 제거.

---

## 5. 트러블슈팅 및 버그 수정 기록

### 5.1. 이벤트 로그 표시 누락 문제 해결
**현상**: Com 포트로 트랩 데이터는 수신되나, Event Log 탭(Traffic Log)에 로그가 표시되지 않음.
**원인 분석**:
1.  **필터 접두사(Prefix) 누락**: 리팩토링 과정에서 메시지 생성을 간소화하며 `[T:]`, `[P:]` 접두사를 제거함. `LogViewModel`의 필터 로직(`IsTrafficLog`)이 해당 접두사를 기준으로 트래픽 로그 여부를 판단하여 발생한 필터링 문제.
2.  **데이터 파싱 인덱스 하드코딩**: 특정 벤더(NTT) 장비에 맞춰진 변수 인덱스(2번: Level, 3번: Category) 참조 로직이 범용 트랩 데이터를 만났을 때 `Severity` 판단 오류 및 정보 누락을 야기함.

**수정 내용**:
*   **프리픽스 복구**: `EventHandlingService`에서 `AddEvent` 호출 시 `[T:장비명]:` 형식을 갖추도록 복구하여 필터링 엔진과의 호환성 확보.
*   **범용 파싱 엔진 도입**: 특정 인덱스에 의존하지 않고 모든 SNMP Variable을 루프 돌며 수집하도록 로직 개선. 문자열 내 키워드(`error`, `fail`, `warning`)를 분석하여 지능적으로 `Severity`를 추론하도록 보강.

**결과**:
*   미등록 장비 및 다양한 벤더의 트랩이 Event Log 탭에 안정적으로 표시됨.
*   장비 상태(Status)와 로그 메시지가 일관성 있게 업데이트됨.

### 5.2. 이벤트 로그 뷰 UI 개선 (`Clear`, `Copy`, `Save`, `Auto-scroll`)
**작업 배경**: 상단 "Event Log" 탭에 불필요한 정보("Polling ALL")가 노출되고 있었으며, 하단 로그 패널에 비해 관리 기능(복사, 저장 등)이 부족하여 사용자 편의성을 위해 하단 로그 패널과 통일된 툴바를 이식함.

**주요 수정 내용**:
1.  **불필요한 헤더 제거**: 시각적으로 혼란을 주던 "Polling ALL" `FilterInfo` 텍스트를 상단 영역에서 삭제.
2.  **로그 관리 툴바 추가**:
    *   **Clear**: 현재 보고 있는 탭의 로그 리스트를 한 번에 삭제하는 기능 구현.
    *   **Copy**: 표시된 로그 전체를 클립보드에 복사하는 기능 추가.
    *   **Save**: 로그를 파일(`.txt`)로 저장하는 독립 기능 구현.
    *   **Auto-scroll**: 새로운 로그가 들어올 때 화면을 가장 아래로 자동 이동시킬지 선택하는 체크박스 추가.
3.  **ViewModel 및 로직 연동**:
    *   `EventLogFilterViewModel`에 `Clear()`, `SaveToFile()`, `CopyToClipboard()` 도메인 로직 추가.
    *   `EventLogTabControl.xaml.cs`에서 `CollectionChanged` 감시를 통해 `Auto-scroll` 상태 옵션을 실제 UI 스크롤 로직에 반영.

**결과**: 
*   하단 로그 정보창과 상단 이벤트 로그 창이 동일한 사용자 경험을 제공함.
*   대규모 로그 발생 시 특정 구간을 보존(Auto-scroll 해제)하거나 즉시 비우는 등 운영 편의성 증대.

---
본 계획서는 개발 진행 상황에 따라 업데이트될 예정입니다.

# 0.1 프로젝트 분석 (전체 개요/클래스 트리/상세 흐름/개선점/파싱 이슈)

작성 기준: `main (origin/main)` / 커밋 `43df691` (update doc for phase2)

---

## 1) 한 줄 요약

`snmpc`는 **C#/.NET 9 + WPF 기반의 “SNMPc 스타일 경량 NMS(Manager)”**를 목표로 하는 프로젝트다.  
현재 커밋은 **VS Code 스타일 레이아웃(좌 ActivityBar + Sidebar + 중앙 탭 + 하단 EventLog)**, **SNMP Test**, **Polling**, **Map 트리(서브넷/디바이스)**, **MIB DB(Compile Mibs 다이얼로그)**, **MIB Table(Walk 결과를 표로 파싱)**까지 구현돼 있다.

---

## 2) 솔루션/레이어 구조 (큰 그림)

### 2.1 솔루션 구성

- `SnmpNms.Core` (net9.0)
  - **계약(Interfaces) + 도메인 모델(Models)**만 존재
- `SnmpNms.Infrastructure` (net9.0, SharpSnmpLib)
  - Core 인터페이스의 **구현체**
  - SNMP 통신/폴링/MIB 파일 파싱/트리 생성
- `SnmpNms.UI` (net9.0-windows, WPF)
  - WPF 화면/상호작용/바인딩
  - 현재는 DI 컨테이너 없이 `MainWindow`에서 구현체를 직접 생성

### 2.2 의존성 방향

```
SnmpNms.UI  ──참조──▶  SnmpNms.Core
    │                     ▲
    └─참조───────────────┘
        (구현체 직접 사용: SnmpNms.Infrastructure)

SnmpNms.Infrastructure ──참조──▶ SnmpNms.Core
```

원칙은 “UI는 인터페이스만 사용”이지만, 현 상태에서는 UI가 `SnmpNms.Infrastructure`까지 직접 참조해 **수동 주입**한다.

---

## 3) 디렉터리 트리(프로젝트 단위)

```
snmpc/
├─ SnmpNms.Core/
│  ├─ Interfaces/
│  │  ├─ ISnmpClient.cs
│  │  ├─ ISnmpTarget.cs
│  │  ├─ IPollingService.cs
│  │  └─ IMibService.cs
│  └─ Models/
│     ├─ DeviceStatus.cs
│     ├─ SnmpVersion.cs
│     ├─ PollingProtocol.cs
│     ├─ SnmpVariable.cs
│     ├─ SnmpResult.cs
│     ├─ PollingResult.cs
│     └─ MibTreeNode.cs
│
├─ SnmpNms.Infrastructure/
│  ├─ SnmpClient.cs
│  ├─ PollingService.cs
│  └─ MibService.cs
│
├─ SnmpNms.UI/
│  ├─ App.xaml / App.xaml.cs
│  ├─ MainWindow.xaml / MainWindow.xaml.cs
│  ├─ MainWindowCommands.cs
│  ├─ Models/ (UI 전용 모델)
│  ├─ ViewModels/
│  ├─ Converters/
│  └─ Views/
│     ├─ ActivityBar.xaml(.cs)
│     ├─ Sidebar.xaml(.cs)
│     ├─ SidebarMapView.xaml(.cs)
│     ├─ Panel.xaml(.cs)          (하단 패널)
│     ├─ MapView/MapViewControl...
│     ├─ EventLog/EventLogTabControl...
│     └─ Dialogs/
│        ├─ DiscoveryPollingAgentsDialog...
│        ├─ DiscoveryProgressDialog...
│        ├─ MapObjectPropertiesDialog...
│        ├─ CompileMibsDialog...
│        └─ 기타...
│
└─ Doc/
   ├─ 0_index.md (문서 인덱스)
   ├─ SnmpNms.Core.md / SnmpNms.Infrastructure.md / SnmpNms.UI.md
   ├─ 7.mib_database.md (MIB Database 정리)
   └─ 기타 설계/로그/운영 문서...
```

---

## 4) 기능 맵(사용자 관점) ↔ 코드 위치

### 4.1 UI 레이아웃(“VS Code 스타일”)

- **ActivityBar(좌)**: `SnmpNms.UI/Views/ActivityBar.xaml(.cs)`
  - Map/Search/EventLog/Settings 뷰 전환 (현재는 Map만 실동, 나머지는 placeholder)
- **Sidebar(좌측 패널)**: `SnmpNms.UI/Views/Sidebar.xaml(.cs)`
  - `CurrentContent`에 뷰를 꽂아 바꿈
- **Editor Area(중앙)**: `MainWindow.xaml`의 `TabControl(tabMain)`
  - Map View / Device / MIB Table / SNMP Test 등
- **BottomPanel(하단)**: `Panel.xaml(.cs)` + `EventLogTabControl`

### 4.2 Map(Selection Tree) / MapView(내부창)

- **Selection Tree**: `SidebarMapView.xaml`의 `TreeView(tvDevices)`
  - ItemsSource: `MainViewModel.MapRoots`
  - 노드 타입: `MapNodeType`(RootSubnet/Subnet/Device/Goto)
  - 상태 표시: `MapNode.EffectiveStatus` → `DeviceStatusToBrushConverter`
  - 우클릭 메뉴: `MainWindowCommands` + `CommandBinding`으로 처리
- **MapView(내부 창)**: `Views/MapView/MapViewControl.xaml(.cs)`
  - 서브넷을 “내부 창”으로 열고(`OpenSubnet`) `CascadeWindows` 제공

### 4.3 Discovery / Map Object Properties

- `Views/Dialogs/DiscoveryPollingAgentsDialog` (Discovery 설정/실행)
- `Views/Dialogs/DiscoveryProgressDialog` (진행 표시)
- `Views/Dialogs/MapObjectPropertiesDialog` (Device/Subnet/Goto 생성/편집)

### 4.4 SNMP Test (GET / GET-NEXT / WALK)

- UI: `MainWindow.xaml`의 “SNMP Test” 탭
- 로직: `MainWindow.xaml.cs`
  - `ExecuteSnmpGet`, `ExecuteSnmpGetNext`, `ExecuteSnmpWalk`
- 통신: `Infrastructure/SnmpClient.cs` (SharpSnmpLib)

### 4.5 Polling(상태 Up/Down)

- 서비스: `Infrastructure/PollingService.cs`
  - `Timer` 기반, 대상 `ConcurrentDictionary`
  - `PollingProtocol`(SNMP/Ping/ARP/None) 분기
- UI 반영: `MainWindow.PollingService_OnPollingResult`
  - `Dispatcher.Invoke`로 UI 스레드에서 `SetDeviceStatus` 호출
  - `MapNode.EffectiveStatus` 재계산 → Sidebar 색상 업데이트

### 4.6 Event Log + 필터

- 모델: `UI/Models/EventLogEntry.cs`
- 필터 VM: `UI/ViewModels/EventLogFilterViewModel.cs`
  - `ICollectionView` + `View.Filter = FilterPredicate`
  - Scope/Severity/SearchText 즉시 반영(`Refresh`)
- 표시 UI: `Views/EventLog/EventLogTabControl.xaml(.cs)`

### 4.7 MIB Database (Compile Mibs)

- 메뉴: `MainWindow.xaml` → `_Config` → `MIB Database...`
- 다이얼로그: `Views/Dialogs/CompileMibsDialog.xaml(.cs)`
  - 선택된 파일들의 “디렉터리”를 모아서 `_mibService.LoadMibModules(dir)` 실행
  - 완료 후 `MainWindow.InitializeMibTree()` 호출(새로고침)

### 4.8 MIB Tree / MIB Table

- **MIB 파서/DB**: `Infrastructure/MibService.cs`
  - `_oidToName`, `_nameToOid` 딕셔너리 구성
  - `GetMibTree()`에서 `MibTreeNode` 트리 구성
- **MIB Table**: `MainWindow.LoadMibTableData()`
  - SNMP WALK 결과(`SnmpVariable`)를 표 형태로 파싱(`ParseWalkResultToTable`)

> 주의: 현재 커밋에는 “MIB Selection Tree(좌측 트리)”가 **UI에 실제로 바인딩되어 있지 않다**.  
> `InitializeMibTree()` 내부에 `_treeMib.ItemsSource = ...`가 TODO로 주석 처리되어 있고, `GetSelectedMibNode()`가 `null`을 반환한다.

---

## 5) 클래스 트리(레이어/기능별)

### 5.1 `SnmpNms.Core` (계약/모델)

#### Interfaces

- `ISnmpClient`
  - `GetAsync(target, oid|oids)`, `GetNextAsync`, `WalkAsync`
- `ISnmpTarget`
  - IP/Port/Community/Version/Timeout/Retries/PollingProtocol 등 “타겟 계약”
- `IPollingService`
  - `Start/Stop`, `AddTarget/RemoveTarget`, `SetInterval`, `OnPollingResult`
- `IMibService`
  - `LoadMibModules`, `GetOidName`, `GetOid`, `GetMibTree`

#### Models

- `SnmpVariable` / `SnmpResult`
  - SNMP 응답 변수 목록 + 응답시간/에러
- `PollingResult`
  - 대상/상태/응답시간/메시지
- `DeviceStatus`
  - Up/Down/Unknown (상태 우선순위가 UI에서 중요)
- `PollingProtocol`
  - SNMP/Ping/ARP/None
- `MibTreeNode`
  - `Name`, `Oid`, `NodeType`, `Children(ObservableCollection)`, `IsExpanded`

### 5.2 `SnmpNms.Infrastructure` (구현체)

- `SnmpClient : ISnmpClient`
  - SharpSnmpLib 래핑
  - `Task.Run`으로 동기 API 호출을 UI 스레드에서 분리
- `PollingService : IPollingService`
  - `Timer` tick마다 대상들을 `Task.WhenAll`로 병렬 Poll
  - Ping/SNMP 분기
- `MibService : IMibService`
  - Regex 기반 MIB 파일 파싱
  - OID↔Name 변환 + MIB 트리 생성

### 5.3 `SnmpNms.UI` (WPF)

#### App / Crash Handling

- `App : Application`
  - `DispatcherUnhandledException`, `DomainUnhandledException`을 `crash.log`로 기록

#### Main Window

- `MainWindow`
  - 서비스 생성(수동 주입)
  - `LoadMibs()` → `InitializeMibTree()`
  - Polling 이벤트 → UI 업데이트 → MapNode 상태 전파
  - SNMP Test(GET/GETNEXT/WALK)
  - MIB Table 로딩/파싱/표 생성

#### ViewModels

- `MainViewModel`
  - MapRoots/SelectedMapNodes/DeviceNodes/SelectedDevice/Events
  - EventLog 탭별 필터 VM들을 생성/유지
- `EventLogFilterViewModel`
  - `ICollectionView` 기반 필터링(스코프/Severity/검색)

#### UI Models

- `UiSnmpTarget : ISnmpTarget, INotifyPropertyChanged`
  - `EndpointKey(ip:port)`, `DisplayName(Alias 우선)`
  - `Status` 변경 시 MapNode에 연쇄 반영
- `MapNode : INotifyPropertyChanged`
  - 트리 구조 + 다중 선택 + `EffectiveStatus` 집계(Down>Unknown>Up)
- `EventLogEntry`
  - 로그 시간/Severity/Device/Message

#### Views

- `ActivityBar`, `Sidebar`, `SidebarMapView`
- `MapViewControl` (내부 창/서브넷 뷰)
- `Dialogs/*` (Discovery, Properties, Compile Mibs 등)

---

## 6) 주요 실행/데이터 흐름(시퀀스)

### 6.1 앱 시작

1. `App.OnStartup()`에서 전역 예외 핸들러 연결
2. `MainWindow()` 생성
3. `MainWindow`가 다음을 수행
   - `_snmpClient = new SnmpClient()`
   - `_mibService = new MibService()`
   - `_pollingService = new PollingService(_snmpClient)`
   - `_vm = new MainViewModel()`, `DataContext = _vm`
   - `_pollingService.OnPollingResult += PollingService_OnPollingResult`
   - `LoadMibs()` (Mib 폴더 로드)
   - `InitializeMibTree()` (트리 생성/노드 카운트 로그)
   - 기본 디바이스를 Map에 추가 후 선택 처리
   - `Loaded` 이벤트에서 `InitializeVSCodeUI()` 실행(사이드바/하단패널 구성)

### 6.2 Polling → Map 상태 전파

1. Polling 시작(`StartPoll` 버튼 또는 Auto Poll 체크)
2. `PollingService`가 주기적으로 각 타겟을 Poll
3. 결과 이벤트 `OnPollingResult`
4. `MainWindow.PollingService_OnPollingResult`가 UI 스레드에서:
   - `SetDeviceStatus(endpointKey, Up|Down)` 호출
   - `FindTargetByKey`로 해당 `UiSnmpTarget` 찾아 `Status` 변경
   - `MapNode`는 `Target.Status` 변경을 감지하여 `RecomputeEffectiveStatus` + 부모 전파

### 6.3 MIB Database(Compile) → 트리 새로고침

1. 메뉴 `Config > MIB Database...` 클릭
2. `CompileMibsDialog`에서 파일 목록 관리
3. Compile 시 파일들의 **디렉터리 집합**에 대해 `LoadMibModules(dir)` 호출
4. 다이얼로그 닫힘 → `MainWindow.InitializeMibTree()` 호출

---

## 7) MIB 파싱/트리 생성 로직(현 구현)과 “파싱/트리 깨짐” 리스크

### 7.1 파서 개요(`MibService.ParseMibFile`)

현재 파서는 **정규식 기반 단순 파서**다.

- 반복(최대 10회)하며 “부모가 먼저 등록되어 있어야 자식 OID를 완성”할 수 있게 구성
- 지원하는 패턴(대표):
  - `OBJECT IDENTIFIER ::= { parent 123 }`
  - `MODULE-IDENTITY ... ::= { parent 37 }`
  - `OBJECT-TYPE ... ::= { parent 1 }`

#### 장점

- “이름 ↔ OID” 매핑을 빠르게 확보 가능
- 최소 기능(MIB 이름 표시, OID→name 변환, 테이블 컬럼명 표시)에 유리

#### 근본 한계(중요)

- `IMPORTS`, 타입/텍스트/SEQUENCE, OID 매크로, multi-line/주석/문법 변형 등을 본격 지원하지 않음
- 부모가 누락되면 자식도 누락(반복으로도 해결 불가한 케이스 존재)
- “테이블/컬럼/인덱스” 구조를 이해하지 못함 → `NodeType` 추정이 어려움

### 7.2 트리 생성(`GetMibTree` → `BuildTreeFromOids` → `SortTree`)

#### 7.2.1 트리 최상위 구조

- 루트: `"Snmp Mibs"`
  - `mgmt` (`1.3.6.1.2.1`) : 표준 MIB
  - `Private` (`1.3.6.1.4.1`) : vendor-specific(enterprises)
  - `Custom-Tables` : 사용자 정의 테이블(현재는 비어있음)

#### 7.2.2 `BuildTreeFromOids`의 핵심 동작

- `_oidToName`를 순회하며 OID가 `mgmt`/`Private` 루트로 시작하는지 판별
- `relativeOid`를 점(`.`) 기준으로 나누어 세그먼트를 따라가며 중간 노드를 생성
  - **중간 노드 이름**: 세그먼트 숫자(`"1"`, `"2"` 같은 문자열)
  - **리프 노드 이름**: `_oidToName`의 실제 MIB 이름(예: `sysDescr`)
- 노드 키(`segmentKey`)로 중복 생성 방지:
  - `segmentKey = $"{rootNode.Name}.{segmentOid}"` 형태

#### 7.2.3 `SortTree`가 만드는 “트리 깨짐” 리스크(중요)

`SortTree`는 단순 정렬이 아니라 **`Children.Clear()` 후 다시 `Add()`**하는 방식이다.

- **리스크 A: UI에서 선택/확장 상태가 사라짐**
  - WPF 트리에서 “선택된 item/컨테이너”는 **객체 참조/컬렉션 변경**에 민감
  - Clear + 재추가가 발생하면, 사용자가 보고 있던 노드가 접히거나, “child가 사라진 것처럼 보이는” 현상이 생길 수 있음
- **리스크 B: 필터링/검색 구현 시 증상이 커짐**
  - 필터 적용을 “원본 트리의 Children을 제거/추가”로 구현하면, 정렬(Clear/Add)까지 겹치면서
    - 트리 컨테이너가 계속 재생성
    - 확장 상태/선택 상태/가상화 상태가 흔들림
    - 특정 vendor subtree(예: `nel`)에서 “자식이 없어짐(혹은 접힘)” 같은 UX 버그로 관찰될 가능성이 큼

> 결론: 트리 UI를 붙이기 시작하면 `SortTree`는 “정렬은 하되 객체/컬렉션을 덜 흔드는 방식”으로 바꾸는 게 안정적이다.  
> 예: 최초 생성 단계에서만 정렬하거나, 별도의 정렬된 View를 사용(Filtering과 함께)하는 방식.

### 7.3 MIB Table 파싱 로직(현 구현)과 한계

`MainWindow.ParseWalkResultToTable(variables, baseOid)`는 WALK 결과를 아래 방식으로 표로 만든다:

- `baseOid` 길이를 기준으로 OID를 쪼개서
  - `columnOid = baseOid + "." + (다음 숫자 1개)`로 컬럼을 추정
  - 나머지 부분을 `instanceKey`로 사용
- 컬럼 헤더는 `_mibService.GetOidName(columnOid)`로 이름 변환을 시도
  - 이름이 없으면 OID를 그대로 컬럼명으로 사용
- 최종 결과는 `List<Dictionary<string, object>>` (row 단위)
  - 항상 `Instance` 컬럼을 먼저 넣고, 나머지 컬럼은 알파벳 순으로 추가

#### 파싱/표시 한계(중요)

- “테이블”이라는 개념을 엄밀히 아는 게 아니라, **OID 구조를 단순 규칙으로 추정**한다.
  - baseOid를 무엇으로 주느냐에 따라 column/instance 분리가 깨질 수 있음
- 컬럼명 변환은 `_mibService`의 파싱 성공 여부에 강하게 의존
  - MIB 파서가 부모를 못 찾으면 그 subtree 전체가 이름 매핑에 실패 → 테이블 헤더가 OID 숫자로 남음

---

## 8) (요청사항 반영) “MIB View Filter 때문에 트리 파서가 안 된다”를 현재 코드에서 어떻게 해석해야 하나

### 8.1 현재 커밋의 사실(팩트)

- UI에 “MIB Selection Tree”가 존재하는 코드 흔적은 있으나,
  - 실제 TreeView 컨트롤 바인딩이 TODO 상태
  - `GetSelectedMibNode()`는 `null` 반환
  - 따라서 “MIB View 필터 UI/로직” 자체가 **현재 커밋에는 없다**

즉, 지금 상태에서 발생 가능한 문제는 “필터”라기보다는:

- `MibService` 파싱 누락/부정확
- `SortTree(Children.Clear())`로 인한 UI 상태 리셋
- MIB 트리 UI가 미완성이라서, MIB Table이 “선택된 노드 기준 자동 연동”을 못 하는 문제

### 8.2 그런데도 ‘필터를 붙이면’ 왜 트리가 깨지기 쉬운가(원인 후보)

필터링을 구현할 때 흔히 하는 실수는 아래 2가지다:

1) **원본 트리의 `Children`을 직접 Remove/Add 하며 필터링**
   - 필터 텍스트가 바뀔 때마다 노드가 사라졌다가 다시 생김
   - 확장/선택/스크롤 위치가 계속 리셋

2) 필터 후에 “정렬”을 다시 돌리면서 `Children.Clear()`를 반복
   - UI 입장에서는 “트리 전체가 계속 갈아끼워짐”
   - 특히 vendor subtree(예: `nel`)처럼 노드 수가 많고 깊은 경우 UX 문제가 두드러짐

> 따라서 “필터 때문에 트리 구조가 파서가 안 된다”는 표현은 실제로는  
> **필터 구현이 트리 구조를 파괴하면서(=원본 컬렉션 변경/재생성), 사용자 눈에는 child가 없어지거나 트리가 붕괴한 것처럼 보이는 문제**로 해석하는 게 자연스럽다.

---

## 9) 개선할 점(우선순위 포함)

### 9.1 1순위(안정성/버그 가능성 높은 구간)

- **MIB Tree UI를 제대로 붙이기 전에, 트리 데이터 구조를 “불변(원본 유지)”로 설계**
  - 원본 트리를 유지하고, 필터는 “View(Projection)”로 해결하는 쪽이 안정적
  - 최소 원칙: 필터 입력마다 원본 `Children`을 지우지 말 것
- **`MibService.SortTree`의 `Children.Clear()` 재구성 방식 개선**
  - UI 바인딩 시작 시점부터는 Clear/Add 방식이 선택/확장 상태를 흔들 가능성이 큼
- **하드코딩 경로 제거**
  - `LoadMibs()`와 `CompileMibsDialog.LoadExistingMibFiles()`에 `D:\git\snmpc\Mib`가 하드코딩
  - 배포/다른 PC에서 즉시 깨짐 → 설정/상대경로/최근 경로 저장 필요

### 9.2 2순위(성능/확장성)

- **`SnmpClient`의 `Task.Run` 사용 최소화**
  - 대량 디바이스/대량 OID 요청 시 스레드풀 압박 가능
  - 취소 토큰/타임아웃/재시도(`Retries`) 반영도 필요
- **`PollingService` 타이머 재진입 제어**
  - 현재 `Elapsed`가 `async void`라 “tick 겹침”이 발생할 수 있음(장비 수 많으면 특히)
  - `SemaphoreSlim`로 한 번에 한 tick만 돌리거나, queue 모델 고려
- **MIB 파서 품질**
  - 현재는 “이름 변환” 수준(최소)
  - 장기적으로는 SMIv2 파서(라이브러리 도입 또는 더 견고한 파싱) 검토

### 9.3 3순위(구조/품질)

- **DI 컨테이너 도입**
  - `MainWindow`가 인프라 구현체를 직접 new
  - 테스트/교체/환경별 구성 어려움 → `Microsoft.Extensions.DependencyInjection` 정도만 도입해도 개선 큼
- **MVVM 경계 정리**
  - `MainWindow.xaml.cs`가 많은 책임을 가짐(통신/파싱/테이블 구성까지)
  - 기능이 커질수록 유지보수 비용 급증
- **CompileMibsDialog의 reflection 제거**
  - “OID 개수 표시”를 위해 private 필드 `_oidToName`를 reflection으로 접근
  - 인터페이스에 `GetOidCount()` 같은 진단용 API를 두거나, 결과 객체를 반환하는 구조가 더 안전

---

## 10) 다음 작업(실행 가능한 제안)

### 10.1 MIB Tree(선택 트리) 완성 로드맵(추천)

- 1) UI에 MIB TreeView를 먼저 붙이되, **원본 트리의 수명/참조를 유지**
  - 선택된 노드는 “참조 안정성”이 가장 중요
- 2) 필터는 “결과 트리”를 새로 만들더라도, 원본을 건드리지 않는 방식으로 구현
  - 필터 결과 트리는 “부모 체인 유지(ancestor 포함)” 규칙이 필요
- 3) 정렬은 최초 빌드 단계에서만 수행하거나, View 레벨에서 수행

### 10.2 MIB Table 고도화(추천)

- baseOid 입력 규칙을 명확히(“table entry OID vs column OID”)
- 컬럼/인스턴스 분리 로직을 RFC/SMIv2 관점으로 재정의(가능하면 MIB 메타를 활용)

---

## 부록) 현재 커밋에서 “없는 것” (문서/기억과 혼동 방지)

- `TrapListener`, `ITrapListener`, `TrapEvent` 등 Trap 관련 구성은 **현재 커밋의 코드에는 존재하지 않는다**(검색/파일 기준).
  - 문서/과거 커밋에서 다뤘다면 “추가 예정/삭제됨/브랜치 차이”로 분리해서 관리하는 것이 안전하다.



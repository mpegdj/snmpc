# MIB Tree 버그 철저 분석

## 분석 일시
2025-12-28

## 비교 대상
- **정상 작동 버전**: 커밋 `8042509` (백업 파일 기준)
- **문제 발생 버전**: 커밋 `75aa832` (현재 HEAD)

---

## 작업 이력

### 2025-12-28 작업 요약

#### 문제 증상
- MIB View에서 `nel` (1.3.6.1.4.1.3930) 하위 노드가 보이지 않음
- `mve5000` 노드가 전혀 보이지 않음
- `mvd5000` 노드가 "IMPORTS"로 잘못 표시됨
- `nel` 노드의 자식 노드가 없음

#### 시도한 해결 방법들

1. **필터링 관련 코드 제거**
   - `MibTreeNode.cs`에서 `IsVisible` 속성 제거
   - `SidebarMibView.xaml`에서 Visibility 바인딩 제거
   - `MainWindow.xaml.cs`에서 필터링 메서드들 제거:
     - `FilterMibTreeByDevice()`
     - `FilterMibTreeNode()`
     - `ResetMibTreeFilter()`
     - `ResetMibTreeNodeFilter()`
     - `SetNodeVisibilityRecursive()`
     - `IsNodeVisible()`
   - 필터링 호출 코드 제거
   - **결과**: 문제 해결 안됨

2. **BuildTreeFromOids 로직 수정**
   - 중간 세그먼트에도 이름이 등록되어 있으면 사용하도록 수정
   - 기존 노드 이름 업데이트 로직 추가
   - **결과**: 문제 해결 안됨

3. **백업 파일로 전체 교체**
   - `MibService.cs`를 백업 버전(8042509)으로 완전 교체
   - `BuildTreeFromOids`를 백업 버전의 단순 로직으로 복원
   - **결과**: 문제 해결 안됨

4. **파싱 로직 디버깅 로그 추가**
   - `nel`, `mve`, `mvd` 관련 OID 파싱 로그 추가
   - 등록 성공/실패 로그 추가
   - **결과**: 로그는 추가되었지만 근본 원인 파악 실패

5. **최신 커밋으로 되돌림**
   - 모든 변경사항을 버리고 HEAD(75aa832) 상태로 복원
   - **결과**: 원래 문제 상태로 복귀

#### 백업 파일 생성
다음 파일들을 `Doc/` 폴더에 백업:
- `MibService_backup_working.cs` - 정상 작동 버전의 MibService
- `MibTreeNode_backup_working.cs` - 정상 작동 버전의 MibTreeNode
- `IMibService_backup_working.cs` - 정상 작동 버전의 IMibService
- `SidebarMibView_backup_working.xaml` - 정상 작동 버전의 SidebarMibView
- `SidebarMibView_backup_working.xaml.cs` - 정상 작동 버전의 SidebarMibView 코드비하인드
- `MainWindow_MibMethods_backup_working.cs` - 정상 작동 버전의 MainWindow MIB 관련 메서드들

#### 결론
- 코드 레벨에서의 비교와 수정으로는 문제 해결 실패
- MIB 파일 파싱 자체에 문제가 있거나, 다른 외부 요인이 작용할 가능성
- 실제 MIB 파일 내용 확인 및 파싱 과정의 상세 디버깅 필요

---

---

## 1. 핵심 차이점 요약

### 1.1 Register() 메서드

**정상 버전 (백업)**:
```csharp
private void Register(string oid, string name)
{
    if (!_oidToName.ContainsKey(oid)) _oidToName[oid] = name;
    if (!_nameToOid.ContainsKey(name)) _nameToOid[name] = oid;
}
```
- **필터링 없음**: 모든 이름을 등록
- **단순함**: OID와 이름만 저장

**문제 버전 (현재)**:
```csharp
private void Register(string oid, string name)
{
    // 키워드 필터링
    if (name.Equals("IMPORTS", ...) || name.Equals("EXPORTS", ...) || ...)
        return;
    
    // 소문자로 시작하지 않으면 등록 안 함
    if (!string.IsNullOrEmpty(name) && !char.IsLower(name[0]))
        return;
    
    if (!_oidToName.ContainsKey(oid)) _oidToName[oid] = name;
    if (!_nameToOid.ContainsKey(name)) _nameToOid[name] = oid;
}
```
- **문제점**: 소문자로 시작하지 않는 이름은 등록되지 않음
- **영향**: `nel`은 소문자로 시작하므로 등록되지만, 다른 유효한 이름들이 제외될 수 있음

### 1.2 ParseMibFile() 정규식

**정상 버전 (백업)**:
```csharp
var oidDefRegex = new Regex(@"^([a-zA-Z0-9_-]+)\s+OBJECT\s+IDENTIFIER\s*::=\s*\{\s*([a-zA-Z0-9_-]+)\s+(\d+)\s*\}", ...);
```
- **패턴**: `[a-zA-Z0-9_-]+` - 대소문자 모두 허용

**문제 버전 (현재)**:
```csharp
var oidDefRegex = new Regex(@"^([a-z][a-zA-Z0-9_-]*)\s+OBJECT\s+IDENTIFIER\s*::=\s*\{\s*([a-zA-Z0-9_-]+)\s+(\d+)\s*\}", ...);
```
- **패턴**: `[a-z][a-zA-Z0-9_-]*` - 소문자로 시작해야 함
- **문제점**: 대문자로 시작하는 이름은 파싱되지 않음

### 1.3 GetMibTree() 메서드

**정상 버전 (백업)**:
```csharp
public MibTreeNode GetMibTree()
{
    var root = new MibTreeNode { ... };
    // CleanInvalidOidNames() 호출 없음
    BuildTreeFromOids(...);
    return root;
}
```

**문제 버전 (현재)**:
```csharp
public MibTreeNode GetMibTree()
{
    CleanInvalidOidNames();  // ⚠️ 문제의 시작점
    var root = new MibTreeNode { ... };
    BuildTreeFromOids(...);
    return root;
}
```

### 1.4 CleanInvalidOidNames() 메서드 (문제 버전에만 존재)

```csharp
private void CleanInvalidOidNames()
{
    var invalidKeys = new List<string>();
    foreach (var kvp in _oidToName)
    {
        var name = kvp.Value;
        if (string.IsNullOrEmpty(name) ||
            name.Equals("IMPORTS", ...) ||
            name.Equals("EXPORTS", ...) ||
            name.Equals("FROM", ...) ||
            name.Equals("BEGIN", ...) ||
            name.Equals("END", ...) ||
            !char.IsLower(name[0]))  // ⚠️ 핵심 문제: 대문자로 시작하는 모든 이름 제거
        {
            invalidKeys.Add(kvp.Key);
        }
    }
    
    // 제거 실행
    foreach (var key in invalidKeys)
    {
        _oidToName.Remove(key);
        _nameToOid.Remove(name);
    }
}
```

**문제점 분석**:
1. `!char.IsLower(name[0])` 조건이 너무 공격적임
2. 유효한 OID 이름도 제거될 수 있음
3. `nel`은 소문자로 시작하므로 제거되지 않지만, **자식 노드들이 제거될 수 있음**

### 1.5 BuildTreeFromOids() 메서드

**정상 버전 (백업)**:
```csharp
for (int i = 0; i < segments.Length; i++)
{
    if (!oidSegments.TryGetValue(segmentKey, out var segmentNode))
    {
        // 마지막 세그먼트인 경우 실제 이름 사용, 아니면 세그먼트 번호 사용
        var nodeName = (i == segments.Length - 1) ? name : segments[i];
        segmentNode = new MibTreeNode { Name = nodeName, ... };
        oidSegments[segmentKey] = segmentNode;
        currentParent.Children.Add(segmentNode);
    }
    currentParent = segmentNode;
}
```
- **로직**: 간단하고 명확
- **중간 세그먼트**: 세그먼트 번호 사용 (예: "3930")
- **마지막 세그먼트**: 실제 이름 사용 (예: "nel")

**문제 버전 (현재)**:
```csharp
for (int i = 0; i < segments.Length; i++)
{
    if (!oidSegments.TryGetValue(segmentKey, out var segmentNode))
    {
        string nodeName;
        if (i == segments.Length - 1)
        {
            // 마지막 세그먼트: 이름 유효성 검증
            if (!string.IsNullOrEmpty(name) && 
                char.IsLower(name[0]) && 
                !name.Equals("IMPORTS", ...) && 
                !name.Equals("EXPORTS", ...))
            {
                nodeName = name;
            }
            else
            {
                nodeName = segments[i];  // 세그먼트 번호 사용
            }
        }
        else
        {
            // 중간 세그먼트: _oidToName에서 이름 찾기 시도
            if (_oidToName.TryGetValue(fullOid, out var segmentName))
            {
                // 유효성 검증
                if (!string.IsNullOrEmpty(segmentName) && 
                    char.IsLower(segmentName[0]) && 
                    !segmentName.Equals("IMPORTS", ...) && 
                    !segmentName.Equals("EXPORTS", ...))
                {
                    nodeName = segmentName;
                }
                else
                {
                    nodeName = segments[i];
                }
            }
            else
            {
                nodeName = segments[i];
            }
        }
        // ... 노드 생성
    }
    else
    {
        // 이미 생성된 노드의 이름 업데이트 로직 (복잡함)
        // ...
    }
}
```
- **로직**: 매우 복잡하고 복잡한 검증 로직
- **문제점**: `CleanInvalidOidNames()`가 먼저 실행되어 필요한 OID가 제거되면, 중간 세그먼트 이름을 찾을 수 없음

---

## 2. 버그 발생 시나리오

### 시나리오 1: CleanInvalidOidNames()가 유효한 OID 제거

1. MIB 파일 파싱 시 `nel` (1.3.6.1.4.1.3930) 등록됨 ✅
2. MIB 파일 파싱 시 `mve5000` (1.3.6.1.4.1.3930.36) 등록됨 ✅
3. MIB 파일 파싱 시 `mvd5000` (1.3.6.1.4.1.3930.37) 등록됨 ✅
4. **`GetMibTree()` 호출**
5. **`CleanInvalidOidNames()` 실행**
   - `nel`: 소문자로 시작 → 제거 안 됨 ✅
   - `mve5000`: 소문자로 시작 → 제거 안 됨 ✅
   - `mvd5000`: 소문자로 시작 → 제거 안 됨 ✅
   - **하지만 다른 중간 세그먼트 OID가 제거될 수 있음**

### 시나리오 2: BuildTreeFromOids()에서 중간 세그먼트 이름 찾기 실패

1. `nel` (1.3.6.1.4.1.3930) 트리 노드 생성
2. `mve5000` (1.3.6.1.4.1.3930.36) 처리 시:
   - 세그먼트: ["3930", "36"]
   - i=0: 세그먼트 "3930" 처리
     - `fullOid = "1.3.6.1.4.1.3930"`
     - `_oidToName.TryGetValue("1.3.6.1.4.1.3930", out segmentName)` → `nel` 찾음 ✅
     - `nodeName = "nel"` ✅
   - i=1: 세그먼트 "36" 처리
     - `fullOid = "1.3.6.1.4.1.3930.36"`
     - `name = "mve5000"` ✅
     - `nodeName = "mve5000"` ✅

**하지만 문제가 발생하는 경우**:
- 만약 `CleanInvalidOidNames()`가 `nel`을 제거했다면?
  - `_oidToName.TryGetValue("1.3.6.1.4.1.3930", ...)` → 실패
  - `nodeName = "3930"` (세그먼트 번호 사용)
  - `nel` 노드가 생성되지 않거나 이름이 "3930"으로 표시됨

### 시나리오 3: 정규식이 이름을 파싱하지 못함

**MIB 파일 내용 예시**:
```
nel                OBJECT IDENTIFIER ::= { enterprises 3930 }
mve5000            OBJECT IDENTIFIER ::= { nel 36 }
mvd5000            OBJECT IDENTIFIER ::= { nel 37 }
```

**정상 버전 정규식** (`[a-zA-Z0-9_-]+`):
- `nel` 매칭 ✅
- `mve5000` 매칭 ✅
- `mvd5000` 매칭 ✅

**문제 버전 정규식** (`[a-z][a-zA-Z0-9_-]*`):
- `nel` 매칭 ✅ (소문자로 시작)
- `mve5000` 매칭 ✅ (소문자로 시작)
- `mvd5000` 매칭 ✅ (소문자로 시작)
- **하지만 대문자로 시작하는 이름은 매칭 안 됨**

---

## 3. 근본 원인 분석

### 원인 1: CleanInvalidOidNames()의 과도한 필터링
- **위치**: `GetMibTree()` 시작 시 호출
- **문제**: `!char.IsLower(name[0])` 조건이 너무 공격적
- **영향**: 유효한 OID도 제거될 수 있음

### 원인 2: Register()의 사전 필터링
- **위치**: `Register()` 메서드
- **문제**: 소문자로 시작하지 않으면 등록 자체가 안 됨
- **영향**: 일부 유효한 이름이 등록되지 않음

### 원인 3: 정규식의 제한적 패턴
- **위치**: `ParseMibFile()`의 정규식
- **문제**: 소문자로 시작하는 이름만 매칭
- **영향**: 대문자로 시작하는 이름은 파싱되지 않음

### 원인 4: BuildTreeFromOids()의 복잡한 로직
- **위치**: `BuildTreeFromOids()` 메서드
- **문제**: 중간 세그먼트 이름을 찾으려고 하지만, `CleanInvalidOidNames()`가 먼저 실행되어 필요한 OID가 제거될 수 있음
- **영향**: 트리 노드 생성 시 이름을 찾지 못해 세그먼트 번호만 사용됨

---

## 4. 실제 문제 발생 케이스

### 케이스 1: nel은 보이지만 자식이 안 보임

**가능한 원인**:
1. `nel` (1.3.6.1.4.1.3930)은 등록되고 제거되지 않음 ✅
2. `mve5000` (1.3.6.1.4.1.3930.36)은 등록되지만, `BuildTreeFromOids()`에서 트리 생성 시 문제 발생
3. `mvd5000` (1.3.6.1.4.1.3930.37)도 동일

**가능한 시나리오**:
- `CleanInvalidOidNames()`가 `nel`을 제거하지 않았지만, 다른 중간 OID를 제거함
- `BuildTreeFromOids()`에서 `nel` 노드를 찾지 못하거나, 자식 노드 생성 시 문제 발생

### 케이스 2: mvd5000이 "IMPORTS"로 표시됨

**가능한 원인**:
1. MIB 파일 파싱 시 `IMPORTS` 키워드가 잘못 파싱되어 OID로 등록됨
2. `BuildTreeFromOids()`에서 `IMPORTS`를 노드 이름으로 사용
3. `CleanInvalidOidNames()`가 `IMPORTS`를 제거하지 못함 (이미 트리에 반영됨)

---

## 5. 해결 방안

### 방안 1: CleanInvalidOidNames() 제거 (가장 권장)
- 정상 작동 버전으로 되돌리기
- `Register()`에서 이미 필터링하므로 중복 필터링 불필요

### 방안 2: CleanInvalidOidNames() 로직 개선
- `!char.IsLower(name[0])` 조건 제거
- 키워드(IMPORTS, EXPORTS 등)만 제거

### 방안 3: Register() 필터링 완화
- 소문자 체크 제거
- 키워드만 필터링

### 방안 4: 정규식 패턴 복원
- `[a-z][a-zA-Z0-9_-]*` → `[a-zA-Z0-9_-]+`
- 대소문자 모두 허용

### 방안 5: BuildTreeFromOids() 단순화
- 정상 버전의 간단한 로직으로 복원
- 중간 세그먼트는 세그먼트 번호 사용

---

## 6. 권장 수정 사항

1. ✅ **`CleanInvalidOidNames()` 메서드 제거**
2. ✅ **`Register()` 메서드의 소문자 체크 제거** (키워드 필터링만 유지)
3. ✅ **정규식 패턴 복원** (`[a-zA-Z0-9_-]+`)
4. ✅ **`BuildTreeFromOids()` 단순화** (정상 버전 로직으로 복원)

---

## 7. 테스트 체크리스트

- [ ] `nel` 노드가 표시되는가?
- [ ] `nel` 하위에 `mve5000` 노드가 표시되는가?
- [ ] `nel` 하위에 `mvd5000` 노드가 표시되는가?
- [ ] `mvd5000`이 "IMPORTS"로 표시되지 않는가?
- [ ] 다른 OID들이 정상적으로 표시되는가?

---

## 8. 실제 시도한 해결 작업 이력

### 2025-12-28 작업 요약

#### 문제 증상
- MIB View에서 `nel` (1.3.6.1.4.1.3930) 하위 노드가 보이지 않음
- `mve5000` 노드가 전혀 보이지 않음
- `mvd5000` 노드가 "IMPORTS"로 잘못 표시됨
- `nel` 노드의 자식 노드가 없음

#### 시도한 해결 방법들

**1. 필터링 관련 코드 제거**
- `MibTreeNode.cs`에서 `IsVisible` 속성 제거
- `SidebarMibView.xaml`에서 Visibility 바인딩 제거
- `MainWindow.xaml.cs`에서 필터링 메서드들 제거:
  - `FilterMibTreeByDevice()`
  - `FilterMibTreeNode()`
  - `ResetMibTreeFilter()`
  - `ResetMibTreeNodeFilter()`
  - `SetNodeVisibilityRecursive()`
  - `IsNodeVisible()`
- 필터링 호출 코드 제거
- **결과**: 문제 해결 안됨

**2. BuildTreeFromOids 로직 수정**
- 중간 세그먼트에도 이름이 등록되어 있으면 사용하도록 수정
- 기존 노드 이름 업데이트 로직 추가
- **결과**: 문제 해결 안됨

**3. 백업 파일로 전체 교체**
- `MibService.cs`를 백업 버전(8042509)으로 완전 교체
- `BuildTreeFromOids`를 백업 버전의 단순 로직으로 복원
- **결과**: 문제 해결 안됨

**4. 파싱 로직 디버깅 로그 추가**
- `nel`, `mve`, `mvd` 관련 OID 파싱 로그 추가
- 등록 성공/실패 로그 추가
- **결과**: 로그는 추가되었지만 근본 원인 파악 실패

**5. 최신 커밋으로 되돌림**
- 모든 변경사항을 버리고 HEAD(75aa832) 상태로 복원
- `git restore` 명령으로 다음 파일들 복원:
  - `SnmpNms.Core/Models/MibTreeNode.cs`
  - `SnmpNms.Infrastructure/MibService.cs`
  - `SnmpNms.UI/MainWindow.xaml.cs`
  - `SnmpNms.UI/Views/SidebarMibView.xaml`
- **결과**: 원래 문제 상태로 복귀

#### 백업 파일 생성
다음 파일들을 `Doc/` 폴더에 백업:
- `MibService_backup_working.cs` - 정상 작동 버전의 MibService (커밋 8042509)
- `MibTreeNode_backup_working.cs` - 정상 작동 버전의 MibTreeNode (커밋 8042509)
- `IMibService_backup_working.cs` - 정상 작동 버전의 IMibService (커밋 8042509)
- `SidebarMibView_backup_working.xaml` - 정상 작동 버전의 SidebarMibView (커밋 8042509)
- `SidebarMibView_backup_working.xaml.cs` - 정상 작동 버전의 SidebarMibView 코드비하인드 (커밋 8042509)
- `MainWindow_MibMethods_backup_working.cs` - 정상 작동 버전의 MainWindow MIB 관련 메서드들 (커밋 8042509)

#### 결론
- 코드 레벨에서의 비교와 수정으로는 문제 해결 실패
- 백업 버전으로 완전 교체해도 문제가 해결되지 않음
- 이는 코드 자체의 문제가 아니라 다른 요인일 가능성:
  - MIB 파일 파싱 자체에 문제가 있거나
  - MIB 파일 내용이 변경되었거나
  - 다른 외부 요인이 작용할 가능성
- 실제 MIB 파일 내용 확인 및 파싱 과정의 상세 디버깅 필요
- 디버그 출력을 통한 실제 파싱 결과 확인 필요

#### 다음 단계 제안
1. 실제 MIB 파일 내용 확인 (`Mib/mve5000/`, `Mib/mvd5000/` 폴더의 파일들)
2. 디버그 출력에서 `nel`, `mve5000`, `mvd5000` 등록 여부 확인
3. `_oidToName` 딕셔너리 내용 확인
4. `BuildTreeFromOids` 실행 시 실제 트리 생성 과정 확인

---

## 2025-12-28 추가 작업: MIB 파싱 순수화 및 초기화 개선

### 작업 배경
- 사용자 요청: "파싱부분의 하드코딩 다 지워 순수하게 mib파일을 읽어서 기본 oid table에 채워넣어"
- 사용자 요청: "oid skeleton빼고 다 지워"
- 사용자 요청: "앱 부트시마다 mib 파일 읽어와서 초기화해"

### 작업 내용

#### 1. 하드코딩 제거 (MibService.cs)

**제거된 하드코딩:**
- 생성자에서 기본 표준 MIB 등록 제거
  - `sysDescr`, `sysObjectID`, `sysUpTime` 등 기본 MIB 제거
  - `iso.org.dod.internet`, `enterprises`, `mgmt` 루트 OID 제거
- `enterprises` 특별 처리 제거
  - OBJECT IDENTIFIER 파싱에서 `enterprises` → `1.3.6.1.4.1` 하드코딩 제거
  - MODULE-IDENTITY 파싱에서 `enterprises` 하드코딩 제거
- `GetMibTree`에서 하드코딩된 노드 생성 제거
  - `mgmt`, `Private`, `Custom-Tables` 노드 하드코딩 제거
  - 파싱된 OID만으로 트리 구성하도록 변경

**변경 전:**
```csharp
public MibService()
{
    Register("1.3.6.1.2.1.1.1", "sysDescr");
    Register("1.3.6.1.4.1", "enterprises");
    Register("1.3.6.1.2.1", "mgmt");
}
```

**변경 후:**
```csharp
public MibService()
{
    // 하드코딩 제거: 모든 OID는 MIB 파일 파싱을 통해서만 등록됨
}
```

#### 2. OID Skeleton만 유지 (일시적 작업)

**남긴 것 (OID skeleton):**
- `_oidToName` Dictionary (OID → Name)
- `_nameToOid` Dictionary (Name → OID)
- `Register` 메서드 (기본 등록 메서드)
- 인터페이스 구현 (빈 구현)

**제거한 것 (일시적):**
- MIB 파일 파싱 로직 (`ParseMibFile`) - 일시적으로 제거
- 정규식 파싱 코드
- 트리 생성 로직 (`BuildTreeFromOids`)
- 트리 정렬 로직 (`SortTree`, `CompareOidForSort`)
- 복잡한 `GetOidName` 로직

**참고:** 이 작업은 skeleton만 남기기 위한 중간 단계였으며, 이후 파싱 로직을 다시 추가함

#### 3. MIB 파일 파싱 로직 재구현

**구현 내용:**
- `LoadMibModules` 메서드 구현
  - MIB 디렉토리에서 `.mib`, `.txt` 파일 검색
  - 각 파일을 `ParseMibFile`로 파싱
- `ParseMibFile` 메서드 구현
  - OBJECT IDENTIFIER 정의 파싱
  - MODULE-IDENTITY 정의 파싱
  - OBJECT-TYPE 정의 파싱
  - 의존성 해결을 위해 최대 10회 반복 파싱
- `GetMibTree` 메서드 구현
  - 파싱된 OID로 트리 구조 생성
  - `BuildTreeFromOids`로 트리 구성
  - `SortTree`로 정렬
- `GetOidName` 메서드 개선
  - 정확한 OID 매칭
  - `.0` 인스턴스 처리
  - Longest Match 알고리즘으로 부분 매칭

**파싱 로직:**
```csharp
// 1단계: OBJECT IDENTIFIER 정의 파싱
var oidDefRegex = new Regex(@"^([a-zA-Z0-9_-]+)\s+OBJECT\s+IDENTIFIER\s*::=\s*\{\s*([a-zA-Z0-9_-]+)\s+(\d+)\s*\}", RegexOptions.Multiline | RegexOptions.IgnoreCase);

// 2단계: MODULE-IDENTITY 정의 파싱
var moduleIdentityRegex = new Regex(@"^([a-zA-Z0-9_-]+)\s+MODULE-IDENTITY[\s\S]*?::=\s*\{\s*([a-zA-Z0-9_-]+)\s+(\d+)\s*\}", RegexOptions.Multiline | RegexOptions.IgnoreCase);

// 3단계: OBJECT-TYPE 정의 파싱
var objectTypeRegex = new Regex(@"^([a-zA-Z0-9_-]+)\s+OBJECT-TYPE[\s\S]*?::=\s*\{\s*([a-zA-Z0-9_-]+)\s+(\d+)\s*\}", RegexOptions.Multiline);
```

#### 4. 트리 생성 로직 단순화

**변경 내용:**
- `BuildTreeFromOids` 단순화
  - 하드코딩된 `mgmt`/`private` 노드 의존성 제거
  - 모든 OID를 루트에서부터 파싱하도록 변경
  - 마지막 세그먼트: 이름 사용
  - 중간 세그먼트: 세그먼트 번호 사용
  - 복잡한 검증 로직 제거

**변경 전:**
```csharp
private void BuildTreeFromOids(MibTreeNode mgmtNode, MibTreeNode privateNode, MibTreeNode customTablesNode)
{
    // mgmt, private 노드에 따라 분기 처리
    if (oid.StartsWith("1.3.6.1.2.1")) { ... }
    else if (oid.StartsWith("1.3.6.1.4.1")) { ... }
}
```

**변경 후:**
```csharp
private void BuildTreeFromOids(MibTreeNode root)
{
    // 모든 OID를 루트에서부터 파싱
    var segments = oid.Split('.');
    var currentParent = root;
    // ...
}
```

#### 5. 앱 부트시 초기화 확인

**현재 구현 상태:**
- `MainWindow` 생성자에서 `LoadMibs()` 호출 (72줄)
- `LoadMibs()` 메서드에서 `_mibService.LoadMibModules(projectRoot)` 호출
- 앱 시작 시 자동으로 MIB 파일 로드 및 초기화

**확인 사항:**
- 이전 버전(백업 파일)에서도 앱 부트시마다 MIB 파일을 읽었음
- 차이점: 이전에는 하드코딩된 기본 MIB가 있었고, 현재는 순수하게 MIB 파일만 파싱

### 최종 상태

**MibService.cs 구조:**
1. OID skeleton (Dictionary, Register 메서드)
2. MIB 파일 파싱 로직 (`LoadMibModules`, `ParseMibFile`)
3. OID 조회 메서드 (`GetOidName`, `GetOid`)
4. 트리 생성 메서드 (`GetMibTree`, `BuildTreeFromOids`, `SortTree`)

**특징:**
- 하드코딩 없음: 모든 OID는 MIB 파일 파싱을 통해서만 등록
- 순수 파싱: MIB 파일만 읽어서 OID 테이블에 채움
- 앱 부트시 초기화: 매번 MIB 파일을 읽어서 초기화

### 참고사항

- `enterprises` 같은 표준 루트 OID는 MIB 파일에서 정의되어야 함
- MIB 파일에 `enterprises` 정의가 없으면 `nel OBJECT IDENTIFIER ::= { enterprises 3930 }` 같은 정의를 파싱할 수 없음
- 필요시 표준 MIB 파일(SNMPv2-SMI 등)을 추가해야 할 수 있음

### 작업 순서 요약

1. 하드코딩 제거 (생성자, enterprises 특별 처리, GetMibTree 노드 생성)
2. OID skeleton만 유지 (일시적 작업)
3. MIB 파일 파싱 로직 재구현
4. 트리 생성 로직 단순화
5. 앱 부트시 초기화 확인

